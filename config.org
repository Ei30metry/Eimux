#+title: Emacs Config
#+author: Artin Ghasivand

* GUI settings
#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t)

(winner-mode 1)
(setq display-line-numbers-type 'relative
      scroll-conservatively 101)
   (if (display-graphic-p)
       (menu-bar-mode 1)
       (menu-bar-mode -1))

(tool-bar-mode -1)
(scroll-bar-mode -1)
(pixel-scroll-precision-mode 1)
(global-visual-line-mode 1)

(use-package ns-auto-titlebar :straight t :config (ns-auto-titlebar-mode 1))
#+end_src

* coding systems
#+begin_src emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8-unix)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+end_src

* mode-line
#+begin_src emacs-lisp
(use-package mood-line
  :straight t)

(column-number-mode 1)
#+end_src
* prog-mode
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'(lambda () (display-line-numbers-mode 1)))
(global-set-key (kbd "<C-m> C-n") 'next-error)
(global-set-key (kbd "<C-m> C-p") 'previous-error)
#+end_src
* comint-mode
#+begin_src emacs-lisp
(add-hook 'comint-mode-hook #'(lambda () (display-line-numbers-mode 1)))
#+end_src
* MISC
#+begin_src emacs-lisp
  (setq disabled-command-function nil)

  (delete-selection-mode t)

  (require 'hl-line)

  (global-hl-line-mode t)

  (setq custom-file (make-temp-name "/tmp/"))

  (add-hook 'before-save-hook #'delete-trailing-whitespace)

  (setq case-fold-search nil)

  (defun camlcase-to-snakecase () (message "TODO"))
  (defun snakecase-to-camlcase () (message "TODO"))
#+end_src
* Buffer
#+begin_src emacs-lisp
  (setq-default message-log-max :error)
  (setq initial-scratch-message nil)

  (setq initial-major-mode 'emacs-lisp-mode)
  (setq switch-to-buffer-obey-display-actions t)

  (setq display-buffer-alist
        '(
          ((or . ((derived-mode . helpful-mode)
                  (derived-mode . idris2-info-mode)
                 "\\*\\(Help\\|haskell-compilation\\|compilation\\|sly-description\\|sly-macroexpansion\\|toc\\)\\*"))
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
            (window-height . 20)
            (dedicated . t)
            (body-function . select-window))

          ("\\*\\(hoogle\\|eldoc for*\\|osx-dictionary\\)\\*"
           (display-buffer-at-bottom)
            (window-height . 15)
            (dedicated . t)
            (body-function . select-window))

          ("\\*Occur\\*"
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
           (window-height . 20)
           (dedicated . t)
           (body-function . select-window))
          ;; NOTE I think we I can replace this by saying comint-mode or ...
          ((or . ((derived-mode . haskell-interactive-mode)
                  (derived-mode . sly-mrepl-mode)
                  (derived-mode . inferior-emacs-lisp-mode)
                 "\\*\\(vterm\\|shell\\|eshell\\|terminal\\|ielm\\|Nix-REPL\\|haskell\\|Racket
  REPL </>\\|Racket Describe </>\\|Racket Logger </>\\|Tex Help\\|idris2-repl\\|terminal\\)\\*"))
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
            (window-height . 22)
            (body-function . select-window))

          ("\\*Org Select\\*"
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
           (window-height . 20)
           (body-function . select-window))
          ("\\*Org Src*"
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
           (window-height . 45)
           (body-function . select-window))
          ("Capture-*"
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
           (window-height . 20)
           (nil . t))

          ((derived-mode . pdf-outline-buffer-mode)
           (display-buffer-reuse-mode-window
            display-buffer-below-selected)
           (window-height . 20)
           (dedicated . t)
           (body-function-select-window))

          ("\\*Async Shell Command\\*"
           (display-buffer-no-window)
           (allow-no-window . t))

          ("\\*Warnings\\*"
           (display-buffer-no-window)
           (allow-no-window . t))
         ))

  (add-hook 'minibuffer-exit-hook
        #'(lambda ()
           (let ((buffer "*Completions*"))
             (and (get-buffer buffer)
              (kill-buffer buffer)))))

  (use-package mode-local
    :straight t)

  (setq-default show-trailing-whitespace nil)

  (setq-mode-local show-trailing-whitespace t)

  (setq-default warning-minimum-level :error)
  (setq make-backup-files nil
        auto-save-default nil
        auto-save-list-file-prefix nil
        create-lockfiles nil)

  (save-place-mode 1)

  (global-set-key (kbd "C-x 4 x g") 'revert-other-buffer-quick)

  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (global-set-key (kbd "C-x K") 'kill-buffer)

  (defun revert-other-buffer-quick ()
    (interactive)
    (message "TODO"))
#+end_src
* Register
#+begin_src emacs-lisp
(setq register-preview-delay nil)
(global-set-key (kbd "C-x r j") 'consult-register-load)

;; TODO Write (next-register) and (previous-register)
;; (global-set-key (kbd "C-x r w i") 'window-configuration-to-register)
#+end_src
* Bookmark
#+begin_src emacs-lisp
(use-package bm
  :straight t)

(use-package bookmark-view
  :straight t)
#+end_src
* Mark
#+begin_src emacs-lisp
(setq set-mark-command-repeat-pop t)
#+end_src
* Window and Frame
** perspective
#+begin_src emacs-lisp
  (use-package perspective ;; TODO use persp instead
    :straight t
    :custom
    (persp-mode-prefix-key (kbd "C-x C-,"))
    :bind
    ("C-x k" . (lambda () (interactive) (persp-kill-buffer* nil)))
    ("C-x K" . persp-kill-buffer*)
    ("C-." . persp-switch-to-buffer*)
    ("C-x b" . switch-to-buffer)
    :init
    (setq persp-initial-frame-name "misc")
    (persp-mode))

  (defun move-persp-to-frame () (message "TODO"))

  (global-set-key (kbd "C-x w s") 'shrink-window)
  (global-set-key (kbd "C-x w m") 'maximize-window)
  (global-set-key (kbd "C-x w u") 'winner-undo)
  (global-set-key (kbd "C-x w r") 'winner-redo)
  (use-package transpose-frame :straight t)
#+end_src
** popper
#+begin_src emacs-lisp
  (use-package popper
    :straight t
    :bind
    ("C-x C-' f" . popper-cycle)
    ("C-x C-' b" . popper-cycle-backwards)
    ("C-,"  . popper-toggle)
    ("C-x C-' t" . popper-toggle-type)
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "\\*Help\\*"
            "\\*hoogle\\*"
            "\\*haskell\\*"
            "\\*Tex Help\\*"
            "\\*toc\\*"
            "\\*Occur\\*"
            "\\*eldoc for\\*$"
            "Output\\*$"
            "\\*Backtrace\\*"
            "\\*Async Shell Command\\*"
            "\\*sly-macroexpansion\\*"
            "\\*sly-description\\*"
            help-mode
            compilation-mode
            haskell-interactive-mode
            comint-mode
            vterm-mode
            pdf-outline-buffer-mode
            helpful-mode
            osx-dictionary-mode
            racket-repl-mode
            nix-repl-mode
            idris2-repl-mode
            idris2-info-mode
            idris2-compiler-notes-mode
            sly-mrepl-mode
            inferior-emacs-lisp-mode
            term-mode
            eshell-mode))
    (popper-mode +1)
    (popper-echo-mode +1))                ; For echo area hints
#+end_src
* UI
** Theme
*** Global theme
#+begin_src emacs-lisp
(use-package doom-themes
   :straight t
   :config
   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
         doom-themes-enable-italic t)
   (doom-themes-visual-bell-config)
   (doom-themes-org-config)
   :init
   (load-theme 'doom-sourcerer t))
#+end_src
*** Buffer specialisation
#+begin_src emacs-lisp
(use-package per-buffer-theme
   :straight t)
#+end_src
** Font
#+begin_src emacs-lisp
(set-face-attribute 'default nil
                    :font "JetBrains Mono 13"
                    :weight 'medium)

(set-face-attribute 'variable-pitch nil
                    :font "JetBrains Mono 13"
                    :weight 'medium)

(set-face-attribute 'fixed-pitch nil
                    :font "JetBrains Mono 13"
                    :weight 'medium)

(add-to-list 'default-frame-alist '(font . "JetBrains Mono 13"))

(use-package ligature :straight t)

;; (set-fontset-font t nil "SF Pro Display" nil 'append)
#+end_src

* Keybindings
** Unsetting some default prefix-keys
Some prefix keys that are still available:
- C-x C-d
- C-x C-n
- C-x C-r
- C-x C-/
- C-x C-y
- C-x C-w
- C-x C-]
- C-x C-j
And probably some more.
#+begin_src emacs-lisp
(global-unset-key (kbd "C-x C-b"))
(global-unset-key (kbd "C-x C-n"))
(global-unset-key (kbd "C-x C-j"))
(global-unset-key (kbd "C-x C-p"))
(global-unset-key (kbd "C-x C-v"))
(global-unset-key (kbd "C-x C-o"))
(global-unset-key (kbd "C-x C-w"))
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x m"))
(global-unset-key (kbd "M-j"))
(global-unset-key (kbd "C-x C-r"))
(global-unset-key (kbd "C-x C-d"))
(global-unset-key (kbd "C-M-u"))
(global-unset-key (kbd "C-M-m"))
#+end_src
** MISC
#+begin_src emacs-lisp
;; NOTE This is not working correctly in emacsclient. I need to manually reload init.el for this to take effect
(define-key input-decode-map [?\C-m] [C-m])

(global-set-key (kbd "C-x C-. C-e o") #'(lambda () (interactive) (find-file "~/.emacs.d/config.org")))
(global-set-key (kbd "C-x C-. C-e r") #'(lambda () (interactive) (load-file "~/.emacs.d/init.el")))

;; TODO  Fix this so that it deletes up to the last space character
(defun zap-up-to-space ()
  (interactive)
  (zap-up-to-char 1 ?\s))

(require 'ibuffer)
(global-set-key (kbd "C-x C-' p") 'previous-buffer)
(global-set-key (kbd "C-x C-' n") 'next-buffer)
(global-set-key (kbd "C-x C-' l") 'persp-ibuffer)
(global-set-key (kbd "C-x C-' s") 'scratch-buffer)
(global-set-key (kbd "C-S-z") 'zap-up-to-space)
(global-set-key (kbd "M-j") 'join-line)
(global-set-key (kbd "M-RET") 'default-indent-new-line)
(global-set-key (kbd "C-x C-n") 'next-error)
(global-set-key (kbd "C-x C-p") 'previous-error)

#+end_src
** C-x C-m as execute-extended-command
#+begin_src emacs-lisp
(global-set-key (kbd "C-x <C-m>") 'execute-extended-command)
#+end_src
** macOS
#+begin_src emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier 'super)
#+end_src
* OS packages
** osx-plist
#+begin_src emacs-lisp
(use-package osx-plist
  :straight t)
#+end_src
** Prevent Emacs from closing
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)

(defun ask-before-closing ()
  "Close only if y was pressed."
  (interactive)
  (if (y-or-n-p (format "Really close frame? "))
      (save-buffers-kill-emacs)
    (message "Canceled frame close")))

(when (daemonp)
  (global-set-key (kbd "C-x C-c") 'ask-before-closing))
#+end_src
* Tools
** consult
#+begin_src emacs-lisp
(use-package consult
   :straight t
   :demand t
   :bind
   ("<C-m> C-i" . consult-imenu)
   ("<C-m> C-s" . consult-line)
   ("M-y" . yank-pop)
   ("M-g g" . consult-goto-line)
   ("M-g M-g" . consult-goto-line)
   ("<C-m> C-d" . consult-mark)
   ("M-g M-m" . consult-mark)
   (:map org-mode-map
   ("<C-m> C-i" . consult-org-heading)))

(setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                   #'consult-completion-in-region
                 #'completion--in-region)
               args)))

(setq xref-show-xrefs-function #'consult-xref
      xref-show-definitions-function #'consult-xref)


#+end_src
*** consult-eglot
#+begin_src emacs-lisp
(use-package consult-eglot
  :straight t
  :after eglot)
#+end_src
*** embark-consult
#+begin_src emacs-lisp
(use-package embark-consult :straight t)
#+end_src
*** consult-hoogle
#+begin_src emacs-lisp
(use-package consult-hoogle
  :straight t
  :after haskell-mode
  :config
  (eval-when-compile
    (defvar vertico-multiform-commands))
  (add-to-list 'vertico-multiform-commands
               '(consult-hoogle buffer)))
#+end_src
*** consult-omni
#+begin_src emacs-lisp
    (use-package consult-omni
      :straight (consult-omni
                 :type git
                 :host github
                 :repo "armindarvish/consult-omni"
                 :files (:defaults "sources/*.el"))
      :config
      (straight-use-package 'request)
      (setq consult-omni-show-preview t
            consult-omni-preview-key "C-i"
            consult-omni-default-count 5
            consult-omni-default-input-throttle 1.7
            consult-embark-default-term #'vterm
            consult-omni-default-browse-function 'browse-url
            consult-omni-default-interactive-command #'consult-omni-multi
            consult-omni-http-retrieve-backend 'request
            consult-omni-open-with-prompt "λ. ")
      (require 'consult-omni-sources)
      (require 'consult-omni-embark)
      (consult-omni-sources-load-modules)
      (setq consult-omni-multi-sources '("calc"
                                         "File"
                                         "Apps"
                                         "Google"
                                         "GitHub"
                                         "Org Agenda")
            consult-omni-web-sources '("Wikipedia"
                                       "Github")))

  (defun consult-omni-web (&optional initial prompt sources no-callback &rest args)
    "Interactive web search”

  This is similar to `consult-omni-multi', but runs the search on
  web sources defined in `consult-omni-web-sources'.  See
  `consult-omni-multi' for more details.
  "
    (interactive "P")
    (let ((prompt (or prompt (concat "[" (propertize "consult-omni-web" 'face 'consult-omni-prompt-face) "]" " Search:  ")))
          (sources (or sources consult-omni-web-sources)))
      (consult-omni-multi initial prompt sources no-callback args)))
#+end_src
*** consult-notmuch
#+begin_src emacs-lisp
  (use-package consult-notmuch
    :straight t
    :after notmuch)
#+end_src
** embark
#+begin_src emacs-lisp
(use-package embark
    :straight t
    :demand t
    :bind
    (:map minibuffer-mode-map
    ("C-." . embark-act))
    :config
    (setq prefix-help-command #'embark-prefix-help-command))
#+end_src
** marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :init
  (marginalia-mode))
#+end_src
** helpful
#+begin_src emacs-lisp
(use-package helpful
  :straight t
  :demand t
  :bind
  ("C-h k" . helpful-key)
  ("C-h v" . helpful-variable)
  ("C-h f" . helpful-callable)
  ("C-h x" . helpful-command)
  ("C-h ." . helpful-at-point)
  ("C-h q" . helpful-kill-buffers))
#+end_src
** iedit
#+begin_src emacs-lisp
  (use-package iedit
    :straight t
    :bind
    ("C-M-;" . iedit-mode))
#+end_src
** easy-kill
#+begin_src emacs-lisp
  (use-package easy-kill
    :straight t
    :bind
    ("M-w" . easy-kill)
    ("C-M-SPC" . easy-mark))
#+end_src
** discover-my-major
#+begin_src emacs-lisp
(use-package discover-my-major
  :straight t
  :bind
  ("C-h <C-m> . discover-my-major")
  ("C-h M-m" . discover-my-mode))
#+end_src
** project management
#+begin_src emacs-lisp
(global-set-key (kbd "C-x p /") 'consult-ripgrep)
(global-set-key (kbd "C-x p b") 'consult-project-buffer)
(global-set-key (kbd "C-x p n") 'project-note-file)
(global-set-key (kbd "C-x p C") 'project-recompile)

(use-package direnv :straight t)
#+end_src
** direnv
#+begin_src emacs-lisp
(use-package direnv :straight t)
#+end_src
** yasnippet
#+begin_src emacs-lisp
(use-package yasnippet :straight t)
#+end_src
** align
#+begin_src emacs-lisp
(global-set-key (kbd "C-x M-a M-a") 'align)
(global-set-key (kbd "C-x M-a M-r") 'align-regexp)
(global-set-key (kbd "C-x M-a M-c") 'align-current)
(global-set-key (kbd "C-x M-a M-e") 'align-entire)
#+end_src
** compile
#+begin_src emacs-lisp
(defun comint-ansi-color-process-output ()
    (ansi-color-process-output nil)
    (set (make-local-variable 'comint-last-output-start)
         (point-marker)))

(use-package compile
  :bind
  (:map compilation-mode-map
   ("c" . project-compile))
  :hook (compilation-filter . comint-ansi-color-process-output)
  :config
  (setq compilation-always-kill t))
#+end_src
** imake
#+begin_src emacs-lisp
(use-package imake :straight t)
#+end_src
** replace
#+begin_src emacs-lisp
#+end_src
** diredfl
#+begin_src emacs-lisp
(use-package diredfl
  :straight t
  :init
  (diredfl-global-mode))
#+end_src
** dired
#+begin_src emacs-lisp
(use-package dired
  :bind
  (:map dired-mode-map
   ("C-j" . dired-jump))
  :config
  (setq dired-kill-when-opening-new-dired-buffer t))
#+end_src
** ace-window
#+begin_src emacs-lisp
(use-package ace-window
        :straight t
        :demand t
        :config
        (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
              aw-dispatch-always t)
        :bind
        ("C-x o" . other-window)
        ("M-o" . ace-window))
#+end_src
** avy
#+begin_src emacs-lisp
(use-package avy
    :straight t
    :demand t
    :config (avy-setup-default)
    :bind ("C-;" . avy-goto-word-1)
          ("C-'" . avy-goto-char-in-line)
          ("<C-m> C-c" . avy-goto-char-2)
          ("<C-m> C-l" . avy-goto-line)
          ("<C-m> C-w" . avy-goto-word-1)
          ("<C-m> <C-m>" . avy-goto-word-1)
          (:map isearch-mode-map
           ("C-;" . avy-isearch)))
#+end_src
** zzz-to-char
#+begin_src emacs-lisp
(use-package zzz-to-char
  :straight t
  :bind ("M-z" . zzz-to-char-up-to-char)
  :demand t)
#+end_src
** occur
#+begin_src emacs-lisp
(global-set-key (kbd "<C-m> C-o") 'occur)
#+end_src
** multiple-cursors
#+begin_src emacs-lisp
(use-package multiple-cursors :straight t)
#+end_src
** vundo
#+begin_src emacs-lisp
(use-package vundo
  :straight t
  :demand t
  :bind
  ("C-x u" . vundo))
#+end_src
** undu-fu
#+begin_src emacs-lisp
(use-package undo-fu
  :demand t
  :straight t)
#+end_src
** magit
#+begin_src emacs-lisp
(use-package magit
  :straight t
  :demand t
  :commands magit-status)
#+end_src
** forge
#+begin_src emacs-lisp
(use-package forge
  :straight t)
#+end_src
** LSP
*** eglot
#+begin_src emacs-lisp
(setq gc-cons-threshold 100000000)
(use-package eglot
  :ensure nil
  :commands eglot
  :bind
  ("C-c C-e C-e" . eglot)
  (:map eglot-mode-map
  ("C-c C-s" . consult-eglot-symbols)
  ("C-c C-." . eldoc)
  ("C-c C-e C-f" . consult-flymake)
  ("<C-m> C-n" . flymake-goto-next-error)
  ("<C-m> C-p" . flymake-goto-prev-error)
  ("C-c C-a C-c" . eglot-code-actions)
  ("C-c C-e C-t" . eglot-find-typeDefinition)
  ("C-c C-a C-i" . eglot-code-action-inline)
  ("C-c C-a C-e" . eglot-code-action-extract)
  ("C-c C-a C-o" . eglot-code-action-organize-imports)
  ("C-c C-a C-r" . eglot-code-action-rewrite)
  ("C-c C-a C-a" . eglot-code-action-quickfix)
  ("C-c C-e C-r" . eglot-rename)
  ("C-c C-e C-s C-r" . eglot-reconnect)
  ("C-c C-e C-s C-s" . eglot-shutdown)
  ("C-c C-e C-s C-a" . eglot-shutdown-all))
  :config
  (setq-default eglot-workspace-configuration
        '((haskell (plugin (stan (globalOn . :json-false))))))
  (setq eglot-confirm-server-initiated-edits nil))
#+end_src
*** eglot-x
#+begin_src emacs-lisp
(use-package eglot-x
  :straight (eglot-x
	     :type git
	     :host github
	     :repo "nemethf/eglot-x"
	     :files ("*.el"))
  :config
  :after rustic
  (eglot-x-setup))
#+end_src
** smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :straight t
  :demand t
  :config
  (require 'smartparens-haskell)
  (require 'smartparens-racket)
  (require 'smartparens-config)
  :bind
  ("C-M-d" . beginning-of-defun)
  ("C-M-c" . end-of-defun)
  ("C-M-a" . sp-beginning-of-sexp)
  ("C-M-e" . sp-end-of-sexp)
  ("C-M-'" . sp-raise-sexp)
  ("M-["   . sp-backward-down-sexp)
  ("C-M-[" . sp-backward-up-sexp)
  ("M-]"   . sp-down-sexp)
  ("C-M-]" . sp-up-sexp)
  ("C-M-f" . sp-forward-sexp)
  ("C-M-b" . sp-backward-sexp)
  ("C-M-n" . sp-next-sexp)
  ("C-M-p" . sp-previous-sexp)
  ("C-S-b" . sp-backward-symbol)
  ("C-S-f" . sp-forward-symbol)
  ("C-S-d" . sp-kill-symbol)
  ("C-S-<backspace>" . sp-backward-kill-symbol)
  ("M-S-<backspace>" . sp-backward-kill-sexp)
  ("C-M-<backspace>" . sp-delete-symbol)
  ("C-M-k" . sp-kill-sexp)
  ("C-S-k" . sp-kill-symbol)
  ("C-M-u" . sp-forward-slurp-sexp)
  ("C-S-u" . sp-backward-slurp-sexp)
  ("C-M-y" . sp-forward-barf-sexp)
  ("C-S-y" . sp-backward-barf-sexp)
  ("C-M-w" . sp-copy-sexp)
  ("C-c (" . sp-wrap-round)
  ("C-c [" . sp-wrap-square)
  ("C-c {" . sp-wrap-curly)
  ("C-c u" . sp-unwrap-sexp)
  ("C-c r" . sp-rewrap-sexp)
  ("C-M-j" . sp-join-sexp)
  ("C-M-g" . sp-split-sexp)
  ("C-c U" . sp-backward-unwrap-sexp)
  :hook
  (prog-mode . smartparens-mode)
  :init
  (show-smartparens-global-mode))
#+end_src
** hl-todo
#+begin_src emacs-lisp
(use-package hl-todo
  :straight t
  :demand t
  :init
  (global-hl-todo-mode))
#+end_src
** vertico
#+begin_src emacs-lisp
(use-package vertico
  :straight t
  :demand t
  :bind (:map vertico-map
            ("C-n" . vertico-next)
            ("C-p" . vertico-previous))
  :custom
  (vertico-cycle t)
  :init
  (vertico-mode))
#+end_src
** savehist
#+begin_src emacs-lisp
(use-package savehist
    :straight t
    :init
    (savehist-mode))
#+end_src
** orderless
#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
** Terminals
*** term
#+begin_src emacs-lisp
(use-package term
  :config
  (setq explicit-shell-file-name "zsh")
  :hook
  (term-mode . compilation-shell-minor-mode))

#+end_src
*** vterm
#+begin_src emacs-lisp
(use-package vterm
  :demand t
  :hook
  (vterm-mode . compilation-shell-minor-mode)
  :bind
  ("s-\\" . vterm)
  ("s-<return>" . vterm-other-window))
(require 'vterm)
#+end_src
*** eshell
#+begin_src emacs-lisp
  (use-package eshell
    :hook
    (eshell-mode . compilation-shell-minor-mode))
#+end_src
*** shell
#+begin_src emacs-lisp
(use-package shell :hook (shell-mode . compilation-shell-minor-mode))
#+end_src
** dumb-jump
+ [ ] when it comes to haskell-mode, ag is more accurate, but unfortunately slower. Have mode-specific values for the dump-jump-force-searcher variable.
#+begin_src emacs-lisp
(use-package dumb-jump
    :straight t
    :demand t
    :config
    (setq dumb-jump-force-searcher 'ag))
#+end_src
** xref
#+begin_src emacs-lisp
(use-package xref
  :straight t
  :config
  (setq xref-prompt-for-identifier nil))

(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
#+end_src
** tab configuration
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default default-tab-width 4)
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src
** sr-speedbar
+ [ ] Use the theme's faces insated of the ugly ones provided by speedbar.
+ [ ] Write a sr-speedbar-toggle-and-switch function to avoid having to switch to the speedbar buffer after opening it using C-\. Kind of like popper-toggle.
+ [ ] Write a function that would expand a line if it's contracted, and contract it if it's expanded.
+ [ ] The speedbar window should always be the left-most window! not a window next to the current window.
#+begin_src emacs-lisp
  (use-package sr-speedbar
    :straight t
    :config
    (speedbar-add-supported-extension ".hs")
    (setq speedbar-use-images nil
          sr-speedbar-right-side nil)
    :bind
    ;; ("C-\\" . sr-speedbar-toggle)
    (:map speedbar-mode-map
          ("<TAB>" . speedbar-expand-line)
          ("<backtab>" . speedbar-contract-line)
          ("q" . sr-speedbar-close)
          ("Q" . nil)))

  ;; (defun sr-speedbar-toggle-and-switch ()
  ;;   (interactive)
  ;;   (if (not (equal (current-buffer) sr-speedbar-buffer-name))
  ;;       (progn
  ;;         (sr-speedbar-open)
  ;;         (switch-to-buffer sr-speedbar-buffer-name))
  ;;     (sr-speedbar-close)))
#+end_src
** treemacs
#+begin_src emacs-lisp
  (use-package treemacs
    :straight t
    :bind
    ("C-\\" . treemacs)
    :config
    (treemacs-project-follow-mode)
    (treemacs-display-current-project-exclusively)
    (treemacs-git-mode -1))
#+end_src
** org
#+begin_src emacs-lisp

  (use-package org
    :bind
    ("C-x A" . org-agenda)
    ("C-," . popper-toggle)
    ("C-S-c" . org-capture)
    (:map org-mode-map ("C-S-c" . org-capture) ("C-," . nil) ("C-'" . nil))
    :config
    (setq org-startup-indented t
          org-directory "~/Agenda"
          org-log-into-drawer t
          org-treat-insert-todo-heading-as-state-change t
          org-hide-emphasis-markers t
          org-return-follows-link t
          org-src-tab-acts-natively nil
          org-agenda-files '("~/Agenda/tasks.org"  "~/Agenda/projects/specification.org"))
    :hook
    (org-agenda-mode . (lambda () (visual-line-mode -1) (toggle-truncate-lines 1))))

  (require 'org-tempo)
  (setq org-structure-template-alist
        '(("el" . "src emacs-lisp")
          ("py" . "src python")
          ("sq" . "src sql")
          ("hs" . "src haskell")
          ("t" . "src tex")
          ("rs" . "src rust")
          ("c"  . "src c")
          ("tx" . "src txt")
          ("o" . "src ott")))
#+end_src
*** org-books
#+begin_src emacs-lisp
(use-package org-books
 :straight t
 :after org
 :config
 (setq org-books-file "~/Agenda/books.org"))
#+end_src
*** org-roam
#+begin_src emacs-lisp
(use-package org-roam
   :straight t
   :after org
   :bind
   ("C-x C-r C-r"     . org-roam-capture)
   ("C-x C-r C-t"     . org-roam-dailies-capture-today)
   ("C-x C-r C-j t"   . org-roam-dailies-goto-today)
   ("C-x C-r w"       . org-roam-refile)
   ("C-x C-r C-j y"   . org-roam-dailies-goto-yesterday)
   ("C-x C-r C-j C-d" . org-roam-dailies-find-directory)
   ("C-x C-r C-j n"   . org-roam-dailies-goto-next-note)
   ("C-x C-r C-j p"   . org-roam-dailies-goto-previous-note)
   ("C-x C-r C-j d"   . org-roam-dailies-goto-date)
   ("C-x C-r b"       . org-roam-buffer-display-dedicated)
   ("C-x C-r C-i r"   . org-roam-ref-add)
   ("C-x C-r C-i t"   . org-roam-tag-add)
   ("C-x C-r C-i a"   . org-roam-alias-add)
   ("C-x C-r C-i n"   . org-roam-node-insert)
   ("C-x C-r C-f"     . org-roam-node-find)
   (:map org-roam-mode-map ("M-." . org-roam-ref-find))
   :config
   (setq org-roam-directory "~/Roam"
         org-roam-db-autosync-mode t))
#+end_src
*** org-roam-ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
    :bind
    ("C-x C-r C-u" . org-roam-ui-open)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src
*** org-roam-bibtex
#+begin_src emacs-lisp
  (use-package org-roam-bibtex
    :straight t)
#+end_src
*** toc-org
#+begin_src emacs-lisp
(use-package toc-org
 :straight t
 :after org
 :hook
 (org-mode . toc-org-mode))
#+end_src
** Tex
*** cdlatex
#+begin_src emacs-lisp
(use-package cdlatex
    :straight t)
#+end_src
*** auctex
#+begin_src emacs-lisp
  (use-package auctex
      :straight t
      :demand t
      :hook
      (LaTeX-mode . reftex-mode)
      (LaTeX-mode . cdlatex-mode)
      (LaTeX-mode . jinx-mode)
      (LaTeX-mode . display-line-numbers-mode)
      (LaTeX-mode . prettify-symbols-mode)
      (LaTeX-mode . smartparens-mode)
      :bind
      ;; (:map LaTeX-mode-map
      ;; ("<C-m> C-w" . avy-goto-subword-1)
      ;; ("<C-m> <C-m>" . avy-goto-subword-1)
      ;; ("C-S-f" . subword-forward)
      ;; ("C-S-b" . subword-backward)
      ;; ("C-S-k" . subword-kill)
      ;; ("C-S-t" . subword-transpose)
      ;; ("C-<backspace>" . subword-backward-kill))
      :mode
      ("\\.tex\\'" . LaTeX-mode)
      ("\\.mng\\'" . LaTeX-mode)
      ("\\.lhs\\'" . LaTeX-mode))
#+end_src
** citar
#+begin_src emacs-lisp
  (use-package citar
    :straight t
    :config
    (setq citar-bibliography '("~/Research/artin.bib"))
    :hook
    (LaTeX-mode . citar-capf-setup)
    (org-mode . citar-capf-setup))

  (use-package citar-embark
    :after citar embark
    :no-require
    :config (citar-embark-mode))

  (use-package citar-org-roam
    :after (citar org-roam)
    :config (citar-org-roam-mode))

#+end_src
** biblio
#+begin_src emacs-lisp
  (use-package biblio
    :straight t
    :config
    (require 'biblio-download))
#+end_src
** markdown-mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t)
#+end_src
** ott
#+begin_src emacs-lisp
  (use-package ott-mode
      :demand t
      :load-path "~/.emacs.d/ott-mode"
      :hook
      (ott-mode . smartparens-mode)
      (ott-mode . (lambda () (display-line-numbers-mode 1))))

  (push 'ott compilation-error-regexp-alist)
  (push '(ott "File \\([a-zA-Z0-9/\\._-]+\\) on line \\([0-9]+\\).*$" 1 2 nil) compilation-error-regexp-alist-alist)
#+end_src
* Media
** emms
#+begin_src emacs-lisp
  (use-package emms
    :straight t
    :demand t
    :config
    (require 'emms-setup)
    (emms-all)
    (setq emms-player-list '(emms-player-mpv)
          emms-info-functions
            '(emms-info-native
              emms-info-metaflac
              emms-info-ogginfo)
          emms-add-directory
            '("/Users/artin/.telega/cache/music/")
          emms-browser-covers #'emms-browser-cache-thumbnail-async
          emms-browser-thumbnail-small-size 64
          emms-browser-thumbnail-medium-size 128)
     :bind
     ("C-x C-v b" . emms-browser)
     ("C-x C-v p" . emms-pause)
     ("C-x C-v s" . emms-seek))

  (setq episodes-audio-directory "/Users/artin/Podcast/Haskell Interlude/Episodes/"
        episodes-notes-directory "/Users/artin/Podcast/Haskell Interlude/Notes/"
        default-description "Volume drop")

  (defun write-timerange (buffer &optional description)
      "Write the timestamp of the currently playing episode to its note file"
      (interactive)
      (let* ((timestamp (emms-track-get (emms-playlist-current-selected-track) 'info-playing-time))
            (timestamp-range (concat (emms-playing-time-format-time (- (truncate timestamp) 1))
                                     " -- "
                                     (emms-playing-time-format-time (+ (truncate timestamp) 1)))))

          (save-excursion (with-current-buffer (get-buffer-create buffer)
                               (if description
                                  (insert (concat timestamp-range " : " description "\n"))
                                  (insert (concat timestamp-range " : " default-description "\n")))))))

  (defun episode-note-buffer ()
    (file-name-sans-extension (file-name-nondirectory (emms-track-name (emms-playlist-current-selected-track)))))


  (defun write-to-episode-note-buffer (&optional description)
    (interactive)
    (write-timerange (episode-note-buffer) description))


  (defun enter-episode-note-then-write (note)
    (interactive
     (progn
       (emms-pause)
       (let
           ((note (read-string "Note: " nil)))
         (list note))))
    (write-to-episode-note-buffer note)
    (emms-pause))

  (defun open-episode-note-buffer () (interactive) (switch-to-buffer (episode-note-buffer)))

  (global-set-key (kbd "C-x C-v C-v") 'enter-episode-note-then-write)

  (global-set-key (kbd "C-x C-v s") 'emms-seek)
  (global-set-key (kbd "C-x C-v o") 'open-episode-note-buffer)
#+end_src
** lyrics-fetcher
#+begin_src emacs-lisp
(use-package lyrics-fetcher
  :straight t
  :after (emms))
#+end_src
** read-player
#+begin_src emacs-lisp
(use-package read-player
  :straight (ready-player
	     :type git
	     :host github
	     :repo "xenodium/ready-player"
	     :files ("*.el" "data"))
  :commands (ready-player-mode))
#+end_src
* Document
** olivetti
#+begin_src emacs-lisp
(use-package olivetti :straight t)
#+end_src
** nov
#+begin_src emacs-lisp
(defun reading-setup ()
   "Sets a fixed width (monospace) font in current buffer"
   (interactive)
   (face-remap-add-relative 'variable-pitch :family "Canela Text"
                                           :height 1.2)
   (text-scale-set 1))

(use-package nov
   :straight t
   :demand t
   :bind
   (:map nov-mode-map
   ("j" . osx-dictionary-search-word-at-point))
   :mode
   (("\\.epub\\'" . nov-mode))
   :hook
   (nov-mode . olivetti-mode)
   (nov-mode . reading-setup))
#+end_src
** doc-view-mode
#+begin_src emacs-lisp
#+end_src
** image-roll
#+begin_src emacs-lisp

#+end_src
** pdf-tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :demand t
  :bind
  (:map pdf-view-mode-map ("g" . revert-buffer-quick)
                          ("M-s o" . occur)
                          ("<C-m> C-o" . occur)
                          ("o" . pdf-outline)
                          ("M-g M-g" . pdf-view-goto-page))
  :mode
  (("\\.pdf\\'" . pdf-view-mode))
  :config
  (auto-revert-mode 1)
  (setq auto-revert-verbose nil
        pdf-view-use-scaling t)
  :hook
  (pdf-view-mode . pdf-view-midnight-minor-mode))
#+end_src
** djvu
#+begin_src emacs-lisp
(use-package djvu :straight t)
#+end_src
** djvu3
#+begin_src emacs-lisp
(use-package djvu3 :straight (djvu3 :type git :host github :repo "dalanicolai/djvu3" :files (".el")))
#+end_src
* Programming Languages
#+begin_src emacs-lisp
(global-set-key (kbd "C-c C-.") 'eldoc)
#+end_src
** Haskell
*** hindent
#+begin_src emacs-lisp
(use-package hindent
  :straight t
  :after haskell-mode)

(defun hindent-reformat-align-decl ()
"Re-format current declaration using hindent, then align"
  (interactive)
  (let ((start-end (hindent-decl-points)))
    (when start-end
      (let ((beg (car start-end))
            (end (cdr start-end)))
        (hindent-reformat-region beg end t)
        (align beg end)))))


(defun hindent-reformat-align-region (beg end)
"Re-format regionn using hindent, then align"
  (interactive "r")
  (hindent-reformat-region beg end t)
  (align beg end))
#+end_src
*** GHC specific
#+begin_src emacs-lisp
(defvar ghc-repo-url "https://gitlab.haskell.org/ghc/ghc/")

;; TODO refactor the following functions into a function called "open-ghc-stuff-at-point"

;; TODO write a dwim version that determines whether the number at point is a

(defun open-ghc-issue-at-point ()
  (interactive)
  (browse-url (concat ghc-repo-url "-/issues/" (number-to-string (number-at-point)))))

(defun open-ghc-MR-at-point ()
  (interactive)
  (browse-url (concat ghc-repo-url "-/merge_requests/" (number-to-string (number-at-point)))))
#+end_src
*** dante
#+begin_src emacs-lisp
  ;; (use-package dante
  ;;   :straight t ; ask use-package to install the package
  ;;   :commands 'dante-mode
  ;;   :hook
  ;;   (dante-mode . (lambda my-fix-hs-eldoc () (setq eldoc-documentation-strategy #'eldoc-documentation-default)))
  ;;   (dante-mode . flymake-mode)
  ;;   :init
  ;;   (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake)
  ;;   :config
  ;;   (require 'flymake-flycheck)
  ;;   (defalias 'flymake-hlint
  ;;     (flymake-flycheck-diagnostic-function-for 'haskell-hlint))
  ;;   (add-to-list 'flymake-diagnostic-functions 'flymake-hlint))
    ;; flycheck backend deprecated October 2022
    ;; (flycheck-add-next-checker 'haskell-dante '(info . haskell-hlint)))
#+end_src
*** [[consult-hoogle]]
*** haskell-mode
#+begin_src emacs-lisp
  (require 'newcomment)

  (defun comment-or-uncomment-decl ()
  "Comment or uncomment current declaration."
    (interactive)
    (let ((start-end (hindent-decl-points)))
      (let ((beg (car start-end))
            (end (cdr start-end)))
        (comment-or-uncomment-region
         (save-excursion
           (goto-char beg)
           (push-mark))
         (save-excursion
           (goto-char end))))))

  (defun insert-haskell-undefined ()
    (interactive)
    (insert "undefined"))

  (use-package haskell-mode
    :straight t
    :demand t
    :config
    (require 'subword)
    (setq haskell-font-lock-symbols t
          haskell-stylish-on-save nil
          haskell-process-log t
          haskell-process-sugggest-hoogle-imports t)
    :bind
    (:map haskell-mode-map
          ("<C-m> C-w" . avy-goto-subword-1)
          ("<C-m> <C-m>" . avy-goto-subword-1)
          ("C-;" . avy-goto-subword-1)
          ("C-c M-o" . haskell-mode-tag-find)
          ("C-c h" . consult-hoogle)
          ("C-c C-o" . haskell-interactive-bring)
          ("C-c i p" . haskell-command-insert-language-pragma)
          ("C-c C-u" . insert-haskell-undefined)
          ("C-c i s" . haskell-mode-toggle-scc-at-point)
          ("C-c C-d" . haskell-process-do-info)
          ("C-c i m" . haskell-add-import)
          ("C-c m" . haskell-navigate-imports)
          ("C-c C-n" . haskell-ds-forward-decl)
          ("C-c C-p" . haskell-ds-backward-decl)
          ("M-n" . haskell-ds-forward-decl)
          ("M-p" . haskell-ds-backward-decl)
          ("M-g M-w" . avy-goto-subword-1)
          ("C-S-f" . subword-forward)
          ("C-S-b" . subword-backward)
          ("C-S-d" . subword-kill)
          ("C-S-t" . subword-transpose)
          ("C-<backspace>" . subword-backward-kill)
          ("M-S-<backspace>" . subword-backward-kill))
    :hook
    (haskell-mode . haskell-auto-insert-module-template)
    (haskell-mode . interactive-haskell-mode)
    (haskell-mode . haskell-indentation-mode)
    (haskell-mode . haskell-decl-scan-mode)
    (haskell-mode . hindent-mode))

  (with-eval-after-load 'align
    (add-to-list 'align-rules-list
                      '(haskell-types
                        (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-assignment
                        (regexp . "\\(\\s-+\\)=\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-arrows
                        (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-left-arrows
                        (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-types
                        (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-assignment
                        (regexp . "\\(\\s-+\\)=\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-arrows
                        (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode))))
         (add-to-list 'align-rules-list
                      '(haskell-left-arrows
                        (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                        (modes quote (haskell-mode haskell-literate-mode)))))
#+end_src
*** haskell-ng-mode
#+begin_src emacs-lisp
  ;; (use-package haskell-ng-mode
  ;;   :straight (:type git
  ;;              :repo "https://gitlab.com/magus/haskell-ng-mode"
  ;;              :branch "main")
  ;;   :init
  ;;   (add-to-list 'treesit-language-source-alist '(haskell "https://github.com/tree-sitter/tree-sitter-haskell"))
  ;;   (add-to-list 'treesit-language-source-alist '(cabal "https://gitlab.com/magus/tree-sitter-cabal.git"))
  ;;   (treesit-install-language-grammar 'haskell)
  ;;   (treesit-install-language-grammar 'cabal)
  ;;   )
#+end_src
*** w3m-haddock
#+begin_src emacs-lisp
(use-package w3m :straight t)

(setq w3m-mode-map (make-sparse-keymap))


(require 'w3m-haddock)
(add-hook 'w3m-display-hook 'w3m-haddoc-display)
#+end_src
*** haskell-snippets
#+begin_src emacs-lisp
(use-package haskell-snippets
  :straight t)
#+end_src
** Agda
#+begin_src elisp
(setq agda-mode-directory
      (file-name-directory (substring (shell-command-to-string "agda-mode locate") 0 -1)))

(add-to-list 'load-path agda-mode-directory)

(use-package agda2-mode
  :ensure nil
  :demand t
  :mode (("\\.agda\\'" . agda2-mode)
         ("\\.lagda.md\\'" . agda2-mode))
  :bind
  (:map agda2-mode-map
        ("<C-m> C-w" . avy-goto-subword-1)
        ("<C-m> <C-m>" . avy-goto-subword-1)
        ("C-c h" . agda2-helper-function-type)
        ("C-c C-h" . nil)
        ("C-S-b" . subword-backward)
        ("C-S-d" . subword-kill)
        ("C-S-t" . subword-transpose)
        ("C-<backspace>" . subword-backward-kill)
        ("M-S-<backspace>" . subword-backward-kill)))
#+end_src
** Idris2
#+begin_src emacs-lisp
(use-package idris2-mode
  :straight (idris2-mode
	     :type git
	     :host github
	     :repo "idris-community/idris2-mode"
	     :files ("*.el" "data"))
  :commands (idris2-mode))
#+end_src
** Emacs Lisp
*** macrostep-mode
#+begin_src emacs-lisp
(use-package macrostep :straight t)
#+end_src
*** libraries
#+begin_src emacs-lisp
(use-package dash :straight t)
(use-package llama :straight t)
#+end_src
*** emacs-lisp
#+begin_src emacs-lisp
  (use-package emacs-lisp-mode
    :bind
    (:map emacs-lisp-mode-map
     ("C-c C-k" . eval-buffer)
     ("C-c C-z" . ielm)) ;; TODO write a proper switch-to-ielm
    :hook
    (emacs-lisp-mode . smartparens-strict-mode))
#+end_src
*** ielm
#+begin_src emacs-lisp
  (use-package ielm
    :bind
    (:map inferior-emacs-lisp-mode-map
          ("C-c C-z" . other-window)) ;; TODO write a proper switch-to-buffer
    :hook
    (inferior-emacs-lisp-mode . smartparens-strict-mode))
#+end_src
** Racket
#+begin_src emacs-lisp
(use-package racket-mode
  :straight t
  :demand t
  :hook
  (racket-mode . smartparens-strict-mode)
  (racket-repl-mode . smartparens-strict-mode)
  (racket-mode . racket-xp-mode)
  :bind
  (:map racket-mode-map
   ("C-M-u" . sp-forward-slurp-sexp) ;; TODO This is horrible. Study keymaps.
   ("C-M-y" . sp-forward-barf-sexp))
  (:map racket-repl-mode-map
   ("C-M-u" . sp-forward-slurp-sexp)
   ("C-M-y" . sp-forward-barf-sexp)))
#+end_src
** Common Lisp
*** sly
#+begin_src emacs-lisp
  (use-package sly
    :straight t
    :demand t
    :config
    (setq inferior-lisp-program (executable-find "sbcl")
          sly-completion-mode nil)
    :hook
    (common-lisp-mode . smartparens-strict-mode)
    (lisp-mode . smartparens-strict-mode)
    (sly-mrepl-mode . smartparens-strict-mode)
    :bind
    (:map lisp-mode-map
          ("C-c C-d C-h" . nil)
          ("C-c C-d C-H" . sly-hyperspec-lookup)))
#+end_src
*** sly-macrostep
#+begin_src emacs-lisp
(use-package sly-macrostep :straight t)
#+end_src
*** sly-quicklisp
#+begin_src emacs-lisp
;; (use-package sly-quicklisp :straight t)
#+end_src
*** sly-asdf
#+begin_src emacs-lisp
(use-package sly-asdf :straight t)
#+end_src
** OCaml
#+begin_src emacs-lisp
(use-package tuareg
    :straight t)

(use-package merlin
    :straight t
    :after tuareg)
#+end_src
** Lean
#+begin_src emacs-lisp
(use-package lean4-mode
  :straight (lean4-mode
	     :type git
	     :host github
	     :repo "leanprover/lean4-mode"
	     :files ("*.el" "data"))
  ;; to defer loading the package until required
  :commands (lean4-mode))
#+end_src
** Nix
#+begin_src emacs-lisp
  (use-package nix-mode
     :straight t)

  (defun darwin-rebuild-switch () ())
  (defun nix-channel-update () ())
  (defun nix-collect-garbage-d () ())

  (global-set-key (kbd "C-x C-. C-n o") #'(lambda () (interactive) (find-file "~/.config/nix-darwin/flake.nix")))
  (global-set-key (kbd "C-x C-. C-n r") #'darwin-rebuild-switch)
  (global-set-key (kbd "C-x C-. C-n u") #'nix-channel-update)
  (global-set-key (kbd "C-x C-. C-n d") #'nix-collect-garbage-d)
#+end_src
** Javascript
#+begin_src emacs-lisp
(use-package js2-mode
    :straight t)
#+end_src
** bnf
#+begin_src emacs-lisp
(use-package bnf-mode :straight t)
#+end_src
** Python
#+begin_src emacs-lisp
 ;; (use-package python-mode
 ;;  :straight t
 ;;  :defer t)
#+end_src
** Swift
#+begin_src emacs-lisp
(use-package swift-mode
    :straight t)
#+end_src
** Rust
*** rust-mode
#+begin_src emacs-lisp
(use-package rust-mode
  :straight t)
#+end_src
*** rustic
#+begin_src emacs-lisp
(use-package rustic
  :straight t
  :config
  (setq rustic-lsp-client 'eglot))
#+end_src
*** cargo
#+begin_src emacs-lisp
(use-package cargo
  :straight t)
#+end_src
** Elixir
** Erlang
** Clojure
#+begin_src emacs-lisp

#+end_src
** Java
* Web Stuff
#+begin_src emacs-lisp
  (use-package web-mode
    :straight t)
#+end_src
* Data Serialization
** JSON
#+begin_src emacs-lisp
(use-package json-mode
  :straight t)
#+end_src
** YAML
#+begin_src emacs-lisp
(use-package yaml-mode
   :straight t)
#+end_src
** csv
#+begin_src emacs-lisp
(use-package csv-mode
  :straight t)
#+end_src
* Password management
** pass
#+begin_src emacs-lisp
(use-package pass
  :straight t)
#+end_src
** epa
#+begin_src emacs-lisp
(use-package epa
  :straight t)
#+end_src
* Shell
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-. C-z r") #'(lambda () (interactive) (find-file "~/.zshrc")))
(global-set-key (kbd "C-x C-. C-z p") #'(lambda () (interactive) (find-file "~/.zprofile")))
(global-set-key (kbd "C-x C-. C-z e") #'(lambda () (interactive) (find-file "~/.zshenv")))
#+end_src
* Spelling and Thesaurus
** Jinx
#+begin_src emacs-lisp
(use-package jinx
  :bind
  (:map jinx-mode-map
    ("<C-m> C-j C-n" . jinx-next)
    ("<C-m> C-j C-p" . jinx-previous)))

(require 'jinx)
#+end_src
** powerthesaurus
#+begin_src emacs-lisp
(use-package powerthesaurus
  :straight t
  :bind
  ("M-^" . powerthesaurus-lookup-dwim))
#+end_src
** synosaurus
#+begin_src emacs-lisp
(use-package synosaurus :straight t)
#+end_src
** reverso
#+begin_src emacs-lisp
(use-package reverso :straight t)
#+end_src
** osx-dictionary
#+begin_src emacs-lisp
(use-package osx-dictionary
  :straight t
  :bind
  ("M-#" . osx-dictionary-search-word-at-point)
  (:map osx-dictionary-mode-map ("k" . osx-dictionary-quit)))
#+end_src
* Messaging and Mail
** ement
#+begin_src emacs-lisp
(use-package ement
    :straight t
    :config
    (setq ement-auto-sync nil))
#+end_src
** message-mode
#+begin_src emacs-lisp
(add-hook 'message-mode-hook (lambda () (display-line-numbers-mode 1)))
(add-hook 'message-mode-hook (lambda () (jinx-mode 1)))
(setq message-auto-save-directory "~/.mail/drafts"
      message-kill-buffer-on-exit t)
#+end_src
** telega
#+begin_src emacs-lisp
(defun use-telega-fonts ()
 (interactive)
 (setq buffer-face-set '(:family "Dejavu Sans")))

(use-package telega
    :bind
    (:map telega-chat-mode-map
    ("C-c C-p" . telega-button-backward)
    ("C-c C-n" . telega-button-forward))
    :hook
    (telega-root-mode . use-telega-fonts)
    (telega-chat-mode . use-telega-fonts)
    :config
    (setq telega-chat-bidi-display-reordering t
          telega-use-images t))

(require 'telega)
#+end_src
** notmuch
#+begin_src emacs-lisp
(setq user-full-name "Artin Ghasivand"
      user-mail-address "ghasivand.artin@gmail.com"
      message-send-mail-function 'smtpmail-send-it
      send-mail-function 'smtpmail-send-it
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-stream-type 'starttls
      smtpmail-smtp-service 587
      message-sendmail-envelope-from 'header
      message-kill-buffer-on-exit t)

(defun fetch-mail-and-refresh ()
  (interactive)
  (shell-command "mbsync -aV")
  (notmuch-poll))

(use-package notmuch
  :straight t
  :demand t
  :bind
  ("C-x m" . notmuch)
  ("C-x M" . notmuch-mua-mail)
  (:map notmuch-hello-mode-map
   ("F" . fetch-mail-and-refresh)))
#+end_src
*** notmuch-addr
#+begin_src emacs-lisp
(use-package notmuch-addr :straight t)
#+end_src
** BBDB
#+begin_src emacs-lisp
  ;; (use-package bbdb :straight t)
#+end_src
* RSS
** elfeed
#+begin_src emacs-lisp
  (use-package elfeed
     :straight t
     :commands (elfeed)
     :config
     (setq elfeed-db-directory "~/.elfeed"
           elfeed-feeds '(("https://planet.haskell.org/atom.xml" haskell PL)
                          ("https://haskell.pl-a.net/atom.xml" haskell PL)
                          ("http://www.masteringemacs.org/feed" emacs blog)
                          ("https://lexi-lambda.github.io/feeds/all.atom.xml" haskell lisp blog)
                          ("https://ianthehenry.com/feed.xml" blog)
                          ("https://coot.me/feed.rss" blog haskell)
                          ("https://www.haskellforall.com/feeds/posts/default" blog)
                          ("https://www.williamyaoh.com/feed.atom" haskell blog)
                          ("https://ekmett.github.io/reader/feed/index.html" haskell blog)
                          ("https://math.andrej.com/feed.xml" math logic CS PL blog)
                          ("https://www.michaelpj.com/blog/feed.xml" haskell blog)
                          ("https://rss.arxiv.org/atom/math.LO" math logic)
                          ("https://rss.arxiv.org/rss/cs.DS" CS DS)
                          ("https://rss.arxiv.org/rss/cs.LO" CS logic)
                          ("https://rss.arxiv.org/rss/cs.DM" CS DM)
                          ("https://rss.arxiv.org/rss/cs.PL" CS PL)
                          ("https://rss.arxiv.org/rss/cs.FL" CS PL)
                          ("https://blog.haskell.org/atom.xml" haskell blog)
                          ("https://www.well-typed.com/blog/rss2.xml" haskell))))
  (use-package elfeed-score :straight t)
  (use-package elfeed-org :straight t)
#+end_src
* Profiling
** esup
#+begin_src emacs-lisp
(use-package esup
  :straight t)
#+end_src
** rmsbolt
#+begin_src emacs-lisp
(use-package rmsbolt
  :straight t)
#+end_src
* Process management
#+begin_src emacs-lisp
(use-package prodigy
  :straight t)
#+end_src
* Downloading stuff
#+begin_src emacs-lisp
(use-package aria2 :straight t)
#+end_src
* Fun!
** speed-type
#+begin_src emacs-lisp
(use-package speed-type
    :straight t
    :hook
    (speed-type-mode . olivetti-mode)
    (speed-type-mode . (lambda () (interactive) (text-scale-set 4)))
    :bind
    (:map speed-type-mode-map
     ("C-i" . speed-type--replay))
    :config
    (setq speed-type-default-lang 'English))
#+end_src
** gptel
#+begin_src emacs-lisp
  (use-package gptel
    :straight t
    :demand t
    :config
    (setq gptel-model "Gemeni"
          gptel-backend (gptel-make-gemini "Gemini"
                          :key auth-info-password
                          :stream t)))
#+end_src
** biome
#+begin_src emacs-lisp
  (use-package biome :straight t)
#+end_src

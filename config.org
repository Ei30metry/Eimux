#+title: Emacs Config
#+author: Artin Ghasivand

* GUI settings
#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-message t)

(winner-mode 1)
(setq display-line-numbers-type 'relative
      scroll-conservatively 101)
   (if (display-graphic-p)
       (menu-bar-mode 1)
       (menu-bar-mode -1))

(tool-bar-mode -1)
(scroll-bar-mode -1)
(pixel-scroll-precision-mode 1)
(global-visual-line-mode 1)
#+end_src
* mode-line
#+begin_src emacs-lisp
(column-number-mode 1)
#+end_src
* prog-mode
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'(lambda () (display-line-numbers-mode 1)))
(global-set-key (kbd "<C-m> C-n") 'next-error)
(global-set-key (kbd "<C-m> C-p") 'previous-error)
#+end_src
* comint-mode
#+begin_src emacs-lisp
(add-hook 'comint-mode-hook #'(lambda () (display-line-numbers-mode 1)))
#+end_src
* MISC
#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src
* Buffer
#+begin_src emacs-lisp
(setq-default message-log-max :error)

(setq initial-major-mode 'emacs-lisp-mode)
(setq switch-to-buffer-obey-display-actions t)

(setq display-buffer-alist
      '(
        ("\\*\\(Help\\|haskell-compilation\\|compilation\\).*"
         (display-buffer-reuse-mode-window
          display-buffer-below-selected)
          (window-height . 20)
          (dedicated . t))
        ("\\*hoogle\\*"
         (display-buffer-at-bottom)
          (window-height . 20)
          (dedicated . t))

        ("\\*Occur\\*"
         (display-buffer-reuse-mode-window
          display-buffer-below-selected)
         (window-height . 20)
         (dedicated . t)
         (body-function . select-window))
        ;; NOTE I think we I can replace this by saying comint-mode or ...
        ((or . ((derived-mode . haskell-interactive-mode) "\\*\\(vterm\\|shell\\|eshell\\|terminal\\|ielm\\|Nix-REPL\\|haskell\\)*"))
         (display-buffer-reuse-mode-window
          display-buffer-below-selected)
          (window-height . 20)
          (body-function . select-window))

        ("\\*Org Select\\*"
         (display-buffer-reuse-mode-window
          display-buffer-below-selected)
         (window-height . 20)
         (body-function . select-window))
        ("Capture-*"
         (display-buffer-reuse-mode-window
          display-buffer-below-selected)
         (window-height . 20)
         (nil . t))
        ("\\*Async Shell Command\\*"
         (display-buffer-no-window)
         (allow-no-window . t))
       ))

(add-hook 'minibuffer-exit-hook
      #'(lambda ()
         (let ((buffer "*Completions*"))
           (and (get-buffer buffer)
            (kill-buffer buffer)))))

(use-package mode-local
  :straight t)

(setq-default show-trailing-whitespace nil)

(setq-mode-local show-trailing-whitespace t)
(setq-default warning-minimum-level :error)
(setq make-backup-files nil
      auto-save-default nil
      auto-save-list-file-prefix nil)

(save-place-mode 1)

(global-set-key (kbd "C-x 4 x g") 'revert-other-buffer-quick)

(defun revert-other-buffer-quick ()
  (interactive)
  (message "TODO"))
#+end_src
* Register
#+begin_src emacs-lisp
(setq register-preview-delay nil)
(global-set-key (kbd "C-x r j") 'consult-register-load)

;; TODO Write (next-register) and (previous-register)
;; (global-set-key (kbd "C-x r w i") 'window-configuration-to-register)
#+end_src
* Mark
#+begin_src emacs-lisp
(setq set-mark-command-repeat-pop t)
#+end_src
* Window and Frame
#+begin_src emacs-lisp
(global-set-key (kbd "C-x w s") 'shrink-window)
(global-set-key (kbd "C-x w m") 'maximize-window)
(use-package transpose-frame :straight t)
#+end_src
* UI
** Theme
*** Global theme
#+begin_src emacs-lisp
(use-package doom-themes
   :straight t
   :config
   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
         doom-themes-enable-italic t)
   (doom-themes-visual-bell-config)
   (doom-themes-org-config)
   :init
   (load-theme 'doom-sourcerer t))
#+end_src
*** per-buffer-theme
#+begin_src emacs-lisp
(use-package per-buffer-theme
   :straight t
   :after nov-mode)
#+end_src
** Font
#+begin_src emacs-lisp
(set-face-attribute 'default nil
                    :font "Andale Mono 14"
                    :weight 'medium)

(set-face-attribute 'variable-pitch nil
                    :font "Andale Mono 14"
                    :weight 'medium)

(set-face-attribute 'fixed-pitch nil
                    :font "Andale Mono 14"
                    :weight 'medium)

(add-to-list 'default-frame-alist '(font . "Andale Mono 14"))
#+end_src

* Keybindings
** Unsetting some default prefix-keys
Some prefix keys that are still available:
- C-x C-d
- C-x C-n
- C-x C-r
- C-x C-/
- C-x C-y
- C-x C-w
- C-x C-]
And probably some more.
#+begin_src emacs-lisp
(global-unset-key (kbd "C-x C-b"))
(global-unset-key (kbd "C-x C-n"))
(global-unset-key (kbd "C-x C-v"))
(global-unset-key (kbd "C-x C-o"))
(global-unset-key (kbd "C-x C-w"))
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x m"))
(global-unset-key (kbd "M-j"))
(global-unset-key (kbd "C-x C-r"))
(global-unset-key (kbd "C-x C-d"))
(global-unset-key (kbd "C-M-u"))
(global-unset-key (kbd "C-M-m"))
#+end_src
** MISC
#+begin_src emacs-lisp
;; NOTE This is not working correctly in emacsclient. I need to manually reload init.el for this to take effect
(define-key input-decode-map [?\C-m] [C-m])

(global-set-key (kbd "C-x C-. C-e o") #'(lambda () (interactive) (find-file "~/.emacs.d/config.org")))
(global-set-key (kbd "C-x C-. C-e r") #'(lambda () (interactive) (load-file "~/.emacs.d/init.el")))

;; TODO  Fix this so that it deletes up to the last space character
(defun zap-up-to-space ()
  (interactive)
  (zap-up-to-char 1 ?\s))

(require 'ibuffer)
(global-set-key (kbd "C-x C-' p") 'previous-buffer)
(global-set-key (kbd "C-x C-' n") 'next-buffer)
(global-set-key (kbd "C-x C-' l") 'persp-ibuffer)
(global-set-key (kbd "C-x C-' s") 'scratch-buffer)
(global-set-key (kbd "C-S-z") 'zap-up-to-space)
(global-set-key (kbd "M-j") 'join-line)
(global-set-key (kbd "M-RET") 'default-indent-new-line)
#+end_src
** C-x C-m as execute-extended-command
#+begin_src emacs-lisp
(global-set-key (kbd "C-x <C-m>") 'execute-extended-command)
#+end_src
** macOS
#+begin_src emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier 'super)
#+end_src
* OS packages
** osx-plist
#+begin_src emacs-lisp
(use-package osx-plist
  :straight t)
#+end_src
** Prevent Emacs from closing
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src
* Org-mode
*** org
#+begin_src emacs-lisp
(use-package org
  :straight t
  :bind
  ("C-x A" . org-agenda)
  ("C-S-c" . org-capture)
  (:map org-mode-map ("C-S-c" . org-capture))
  :config
  (setq org-startup-indented t
        org-directory "~/Agenda"
        org-log-into-drawer t
        org-treat-insert-todo-heading-as-state-change t
        org-return-follows-link t
        org-src-tab-acts-natively nil
        org-agenda-files '("~/Agenda/tasks.org" "~/Agenda/schedule.org" "~/Agenda/projects/specification.org")
        org-todo-keywords
        '((sequence "TODO" "FIX" "VERIFY" "REVIEW" "|" "DONE" "DELEGATED" )))
  :hook
  (org-agenda-mode . (lambda () (visual-line-mode -1) (toggle-truncate-lines 1))))
(global-unset-key (kbd "C-'"))
#+end_src
*** org-capture
#+begin_src emacs-lisp
;; NOTE rewrite this using a function
;; NOTE find a better way then putting everything under a menu
(setq org-capture-templates
     '(("t" "Task")
       ("tt" "Planned" entry (file+headline "tasks.org" "Planned") "* TODO %?\nSCHEDULED: %^t\nDEADLINE: %^t")
       ("tT" "Today" entry (file+headline "tasks.org" "Planned") "* TODO %?\nSCHEDULED: %t\nDEADLINE: %t")
       ("tl" "Process later" entry (file+headline "tasks.org" "Inbox") "* TODO %?")
       ("td" "Deadline" entry (file+headline "tasks.org" "Deadline") "* TODO %?\nDEADLINE: %^t")
       ("ts" "Schedule"entry (file+headline "tasks.org" "Schedule") "* TODO %?\nSCHEDULED: %^t")
       ("l" "Lookup")
       ("lr" "Random" entry (file+headline "lookup.org" "Random") "* TODO %?")
       ("lm" "Mathematics" entry (file+headline "lookup.org" "Math") "* TODO %?")
       ("lc" "CS" entry (file+headline "lookup.org" "Computer Science") "* TODO %?")
       ("lp" "Philosophy" entry (file+headline "lookup.org" "Philosophy") "* TODO %?")
       ("le" "Emacs" entry (file+headline "lookup.org" "Emacs") "* TODO %?")

       ("tp" "Project")
       ("tps" "Specification" entry (file+headline "projects/specification.org" "Tasks") "* TODO %?")
       ("tpg" "GHC" entry (file+headline "projects/specification.org" "Tasks") "* TODO %?")
       ("tph" "Hygeia" entry (file+headline "projects/hygeia.org" "Tasks") "* TODO %?")
       ("tc" "Config")
       ("tce" "Emacs" entry (file+headline "config/emacs-config.org" "Tasks") "* TODO %?\n%i")
       ("tcn" "Nix" entry (file+headline "config/nix.org" "Tasks") "* TODO %?\n  %i")
       ("a" "Ask" entry (file+headline "projects/specification.org" "QUESTIONS") "* %^{Ask:|QUESTION|ASKSIMON|ASKRICHARD} %?\nSCHEDULED: %^t")
       ("i" "Idea")
       ("ic" "Config")
       ("ip" "Project")
       ("ips" "Specification" entry (file+headline "projects/specification.org" "Ideas") "* IDEA %?")
       ("ice" "Emacs" entry (file+headline "config/emacs-config.org" "
       Ideas") "* IDEA %?\n  %i\n")
       ("icn" "Nix" entry (file+headline "config/nix.org" "Tasks") "* IDEA %?")
     ))
#+end_src
*** org-contrib
#+begin_src emacs-lisp
(use-package org-contrib
 :straight t
 :after org
 :config
 (require 'ox-extra)
 (ox-extras-activate '(latex-header-blocks ignore-headlines)))
#+end_src
*** org-contacts
#+begin_src emacs-lisp
(use-package org-contacts :straight t)
#+end_src
*** org-mime
#+begin_src emacs-lisp
(use-package org-mime :straight t)
#+end_src
*** org-bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :straight t
  :after org)

(add-hook 'org-mode-hook #'(lambda () (org-bullets-mode 1)))
#+end_src
*** org-tempo
#+begin_src emacs-lisp
(with-eval-after-load 'org
    (require 'org-tempo)
    (setq org-structure-template-alist
         '(("el" . "src emacs-lisp")
           ("py" . "src python")
           ("sq" . "src sql")
           ("hs" . "src haskell")
           ("t" . "src tex")
           ("rs" . "src rust")
           ("c"  . "src c")
           ("tx" . "src txt")
           ("o" . "src ott"))))
#+end_src
*** toc-org
#+begin_src emacs-lisp
(use-package toc-org
 :straight t
 :after org
 :hook
 (org-mode . toc-org-mode))
#+end_src
*** org-roam
#+begin_src emacs-lisp
(use-package org-roam
   :straight t
   :after org
   :bind
   ("C-x C-r C-r"     . org-roam-capture)
   ("C-x C-r C-t"     . org-roam-dailies-capture-today)
   ("C-x C-r C-j t"   . org-roam-dailies-goto-today)
   ("C-x C-r w"       . org-roam-refile)
   ("C-x C-r C-j y"   . org-roam-dailies-goto-yesterday)
   ("C-x C-r C-j C-d" . org-roam-dailies-find-directory)
   ("C-x C-r C-j n"   . org-roam-dailies-goto-next-note)
   ("C-x C-r C-j p"   . org-roam-dailies-goto-previous-note)
   ("C-x C-r C-j d"   . org-roam-dailies-goto-date)
   ("C-x C-r b"       . org-roam-buffer-display-dedicated)
   ("C-x C-r C-i r"   . org-roam-ref-add)
   ("C-x C-r C-i t"   . org-roam-tag-add)
   ("C-x C-r C-i a"   . org-roam-alias-add)
   ("C-x C-r C-i n"   . org-roam-node-insert)
   ("C-x C-r C-f"     . org-roam-node-find)
   (:map org-roam-mode-map ("M-." . org-roam-ref-find))
   :config
   (setq org-roam-directory "~/Roam"
         org-roam-db-autosync-mode t))
#+end_src
*** org-roam-ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :straight
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
    :bind
    ("C-x C-r C-u" . org-roam-ui-open)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src
** Productivity
*** Books
#+begin_src emacs-lisp
(use-package org-books
 :straight t
 :after org
 :config
 (setq org-books-file "~/Agenda/books.org"))
#+end_src
* Media
** emms
#+begin_src emacs-lisp
(use-package emms :straight t)
#+end_src
** empv
#+begin_src emacs-lisp
(use-package empv :straight t)

(setq episodes-audio-directory "/Users/artin/Podcast/Haskell Interlude/Episodes/"
      episodes-notes-directory "/Users/artin/Podcast/Haskell Interlude/Notes/"
      default-description "Volume drop")


(defun timestamp-to-MM-SS (timestamp)
   "Convert seconds to MM:SS format"
   (let* ((seconds (% timestamp 60))
          (minutes (/ (- timestamp seconds) 60))
          (prettify-time (lambda (x) (if (< x 10)
                                       (concat "0" (number-to-string x))
                                       (number-to-string x))))
          (seconds-pretty (funcall prettify-time seconds))
          (minutes-pretty (funcall prettify-time minutes)))
    (concat minutes-pretty ":" seconds-pretty)))


(defun write-timerange (buffer &optional description)
    "Write the timestamp of the currently playing episode to its note file"
    (interactive)
    (let* ((timestamp (empv--send-command-sync (list 'get_property 'time-pos)))
          (timestamp-range (concat (timestamp-to-MM-SS (- (truncate timestamp) 1))
                                   " -- "
                                   (timestamp-to-MM-SS (+ (truncate timestamp) 1)))))

        (save-excursion (with-current-buffer (get-buffer-create buffer)
                             (if description
                                (insert (concat timestamp-range " : " description "\n"))
                                (insert (concat timestamp-range " : " default-description "\n")))))))


(defun timestamp-of-episode ()
  (let ((timestamp (empv--send-command-sync (list 'get_property 'time-pos))))
             (timestamp-to-MM-SS (truncate timestamp))))


(defun episode-note-buffer ()
  (file-name-nondirectory (empv--send-command-sync (list 'get_property 'filename/no-ext))))


(defun write-to-episode-note-buffer (&optional description)
  (interactive)
  (write-timerange (episode-note-buffer) description))


(defun open-episode-note-buffer () (interactive) (switch-to-buffer (episode-note-buffer)))

;; This should be a hydra.
(global-set-key (kbd "C-x C-v C-v") 'write-to-episode-note-buffer)
(global-set-key (kbd "C-x C-v t") #'(lambda () (interactive) (message (timestamp-of-episode))))
(global-set-key (kbd "C-x C-v p") 'empv-pause)
(global-set-key (kbd "C-x C-v r") 'empv-resume)
(global-set-key (kbd "C-x C-v s") 'empv-seek)
(global-set-key (kbd "C-x C-v o") 'open-episode-note-buffer)
#+end_src
* Tools
** perspective
#+begin_src emacs-lisp
(use-package perspective
  :straight t
  :custom
  (persp-mode-prefix-key (kbd "C-x C-,"))
  :bind
  ("C-x k" . persp-kill-buffer*)
  ("C-." . persp-switch-to-buffer)
  ("C-x b" . switch-to-buffer)
  :init
  (persp-mode))
#+end_src
** project
#+begin_src emacs-lisp
(defun project-note-file ()
  (interactive)
  (message "%s" (concat "TODO Implement me! " (project-name (project-current)))))

(global-set-key (kbd "C-x p /") 'consult-ripgrep)
(global-set-key (kbd "C-x p b") 'consult-project-buffer)
(global-set-key (kbd "C-x p n") 'project-note-file)
#+end_src
** align
#+begin_src emacs-lisp
(global-set-key (kbd "C-x M-a M-a") 'align)
(global-set-key (kbd "C-x M-a M-r") 'align-regexp)
(global-set-key (kbd "C-x M-a M-c") 'align-current)
(global-set-key (kbd "C-x M-a M-e") 'align-entire)
#+end_src
** replace
#+begin_src emacs-lisp
#+end_src
** diredfl
#+begin_src emacs-lisp
(use-package diredfl
  :straight t
  :init
  (diredfl-global-mode))
#+end_src
** ace-window
#+begin_src emacs-lisp
(use-package ace-window
        :straight t
        :config
        (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
        (setq aw-dispatch-always t)
        :bind ("M-o" . ace-window))
#+end_src
** avy
#+begin_src emacs-lisp
(use-package avy
    :straight t
    :config (avy-setup-default)
    :bind ("C-;" . avy-goto-char-in-line)
          ("<C-m> C-c" . avy-goto-char-2)
          ("<C-m> C-l" . avy-goto-line)
          ("<C-m> C-w" . avy-goto-word-1)
          ("<C-m> C-," . avy-goto-word-1))
#+end_src
** hydra
#+begin_src emacs-lisp
(use-package hydra :straight t)
#+end_src
** multiple-cursors
#+begin_src emacs-lisp
(use-package multiple-cursors :straight t)
#+end_src
** vundo
#+begin_src emacs-lisp
(use-package vundo :straight t)
#+end_src
** magit
#+begin_src emacs-lisp
(use-package magit
  :straight t
  :commands magit-status)
#+end_src
** eglot
#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)
  (use-package eglot
    :straight t
    :commands eglot
    :config
    (setq-default eglot-workspace-configuration
          '((haskell (plugin (stan (globalOn . :json-false)))))))

#+end_src
** smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :straight t
  :config
  (require 'smartparens-haskell)
  (require 'smartparens-config)
  :bind
  ("C-M-a" . sp-beginning-of-sexp)
  ("C-M-e" . sp-end-of-sexp)
  ("M-["   . sp-backward-down-sexp)
  ("C-M-[" . sp-backward-up-sexp)
  ("M-]"   . sp-down-sexp)
  ("C-M-]" . sp-up-sexp)
  ("C-M-f" . sp-forward-sexp)
  ("C-M-b" . sp-backward-sexp)
  ("C-M-n" . sp-next-sexp)
  ("C-M-p" . sp-previous-sexp)
  ("C-S-b" . sp-backward-symbol)
  ("C-S-f" . sp-forward-symbol)
  ("C-S-k" . sp-kill-symbol)
  ("C-S-<backspace>" . sp-backward-kill-symbol)
  ("M-S-<backspace>" . sp-backward-kill-sexp)
  ("C-M-<backspace>" . sp-delete-symbol)
  ("C-M-k" . sp-kill-sexp)
  ("C-M-u" . sp-forward-slurp-sexp)
  ("C-S-u" . sp-backward-slurp-sexp)
  ("C-M-y" . sp-forward-barf-sexp)
  ("C-S-y" . sp-backward-barf-sexp)
  ("C-M-w" . sp-copy-sexp)
  ("C-c (" . sp-wrap-round)
  ("C-c [" . sp-wrap-square)
  ("C-c {" . sp-wrap-curly)
  ("C-c u" . sp-unwrap-sexp)
  ("C-M-j" . sp-join-sexp)
  ("C-M-g" . sp-split-sexp)
  ("C-c U" . sp-backward-unwrap-sexp)
  :hook
  (prog-mode . smartparens-strict-mode)
  :init
  (show-smartparens-global-mode)
  (smartparens-global-mode))
#+end_src
** hl-todo
#+begin_src emacs-lisp
(use-package hl-todo
  :straight t
  :init
  (global-hl-todo-mode))
#+end_src
** vertico
#+begin_src emacs-lisp
(use-package vertico
  :straight t
  :bind (:map vertico-map
            ("C-n" . vertico-next)
            ("C-p" . vertico-previous))
  :custom
  (vertico-cycle t)
  :init
  (vertico-mode))
#+end_src
** savehist
#+begin_src emacs-lisp
(use-package savehist
    :straight t
    :init
    (savehist-mode))
#+end_src
** orderless
#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
** Terminal
*** term
#+begin_src emacs-lisp
(setq explicit-shell-file-name "zsh")
#+end_src
*** vterm
#+begin_src emacs-lisp
(use-package vterm
  :straight t
  :bind
  ("s-\\" . vterm)
  ("s-<return>" . vterm-other-window))
#+end_src
*** eshell
#+begin_src emacs-lisp
#+end_src
** dumb-jump
#+begin_src emacs-lisp
(use-package dumb-jump
    :straight t
    :config
    (setq dumb-jump-force-searcher 'ag)) ;; TODO Use rg with custom rules for faster search results
#+end_src
** xref
#+begin_src emacs-lisp
(use-package xref
  :straight t
  :config
  (setq xref-prompt-for-identifier nil))

(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
#+end_src
** tab
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default default-tab-width 4)
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src
** embark
#+begin_src emacs-lisp
(use-package embark
    :straight t
    :bind
    (:map minibuffer-mode-map
    ("C-." . embark-act))
    :config
    (setq prefix-help-command #'embark-prefix-help-command))
#+end_src
** consult
#+begin_src emacs-lisp
(use-package consult
   :straight t
   :bind
   ("<C-m> C-i" . consult-imenu)
   ("<C-m> C-s" . consult-line)
   (:map org-mode-map
   ("<C-m> C-i" . consult-org-heading)))

(setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                   #'consult-completion-in-region
                 #'completion--in-region)
               args)))

(setq xref-show-xrefs-function #'consult-xref
      xref-show-definitions-function #'consult-xref)
#+end_src
*** consult-eglot
#+begin_src emacs-lisp
(use-package consult-eglot
  :straight t
  :after eglot)
#+end_src
*** embark-consult
#+begin_src emacs-lisp
(use-package embark-consult :straight t)
#+end_src
** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :init
  (marginalia-mode))
#+end_src
* Document
** olivetti
#+begin_src emacs-lisp
(use-package olivetti :straight t)
#+end_src
** nov
#+begin_src emacs-lisp
(use-package nov
   :straight t
   :mode
   (("\\.epub\\'" . nov-mode))
   :hook
   (nov-mode . olivetti-mode))
#+end_src
** doc-view-mode
#+begin_src emacs-lisp
#+end_src
** pdf-tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :straight t
  :bind
  (:map pdf-view-mode-map ("g" . revert-buffer-quick))
  :mode
  (("\\.pdf\\'" . pdf-view-mode))
  :config
  (auto-revert-mode 1)
  (setq auto-revert-verbose nil
        pdf-view-use-scaling t))
#+end_src
* Programming Languages
** Haskell
*** hindent
#+begin_src emacs-lisp
(use-package hindent
  :straight t
  :after haskell-mode)

(defun hindent-reformat-align-decl ()
"Re-format current declaration using hindent, then align"
  (interactive)
  (let ((start-end (hindent-decl-points)))
    (when start-end
      (let ((beg (car start-end))
            (end (cdr start-end)))
        (hindent-reformat-region beg end t)
        (align beg end)))))


(defun hindent-reformat-align-region (beg end)
"Re-format regionn using hindent, then align"
  (interactive "r")
  (hindent-reformat-region beg end t)
  (align beg end))
#+end_src
*** haskell-mode
#+begin_src emacs-lisp
(require 'newcomment)

(defun comment-or-uncomment-decl ()
"Comment or uncomment current declaration."
  (interactive)
  (let ((start-end (hindent-decl-points)))
    (let ((beg (car start-end))
          (end (cdr start-end)))
      (comment-or-uncomment-region
       (save-excursion
         (goto-char beg)
         (push-mark))
       (save-excursion
         (goto-char end))))
       ))


(use-package haskell-mode
  :straight t
  :config
  (setq haskell-font-lock-symbols t
        haskell-stylish-on-save nil
        haskell-process-log nil)

  :bind
  (:map haskell-mode-map
        ("<C-m> C-w" . avy-goto-subword-1)
        ("<C-m> C-," . avy-goto-subword-1)
        ("C-c h" . hoogle)
        ("C-C C-o" . haskell-interactive-bring)
        ("C-c f" . haskell-mode-stylish-buffer)
        ("C-c i p" . haskell-command-insert-language-pragma)
        ("C-c i m" . haskell-add-import)
        ("C-c m" . haskell-navigate-imports)
        ("C-c C-n" . haskell-ds-forward-decl)
        ("C-c C-p" . haskell-ds-backward-decl)
        ("M-n" . haskell-ds-forward-decl)
        ("M-p" . haskell-ds-backward-decl)
        ("M-g M-w" . avy-goto-subword-1)
        ("C-S-f" . subword-forward)
        ("C-S-b" . subword-backward)
        ("C-S-k" . subword-kill)
        ("C-S-t" . subword-transpose)
        ("C-<backspace>" . subword-backward-kill)
        ("M-S-<backspace>" . subword-backward-kill))
  :hook
  (haskell-mode . haskell-auto-insert-module-template)
  (haskell-mode . interactive-haskell-mode)
  (haskell-mode . haskell-indentation-mode)
  (haskell-mode . haskell-decl-scan-mode)
  (haskell-mode . hindent-mode))

;;(with-eval-after-load 'interactive-haskell-mode
;;  (define-key interactive-haskell-mode-map (kbd "C-c C-c") 'haskell-compile)
;;  (define-key interactive-haskell-mode-map  (kbd "C-c C-b") 'haskell-interactive-switch-back)
;;  (define-key haskell-interactive-mode-map (kbd "C-c C-c") 'haskell-compile)
;;  (define-key haskell-interactive-mode-map  (kbd "C-c C-b") 'haskell-interactive-switch-back))

(defun haskell-scratch-buffer () (mesage "TODO implement me!"))

(with-eval-after-load 'align
  (add-to-list 'align-rules-list
                    '(haskell-types
                      (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-assignment
                      (regexp . "\\(\\s-+\\)=\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-arrows
                      (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-left-arrows
                      (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-types
                      (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-assignment
                      (regexp . "\\(\\s-+\\)=\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-arrows
                      (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode))))
       (add-to-list 'align-rules-list
                    '(haskell-left-arrows
                      (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
                      (modes quote (haskell-mode haskell-literate-mode)))))
#+end_src
         *** w3m-haddock
         #+begin_src emacs-lisp
         (use-package w3m :straight t)

         (setq w3m-mode-map (make-sparse-keymap))


         (require 'w3m-haddock)
         (add-hook 'w3m-display-hook 'w3m-haddoc-display)
         #+end_src
         ** Agda
         #+begin_src elisp
         (setq agda-mode-directory
               (file-name-directory (substring (shell-command-to-string "agda-mode locate") 0 -1)))

         ;; Add the directory containing agda2-mode.el to load-path
         (add-to-list 'load-path agda-mode-directory)

         ;; Use-package configuration for agda2-mode
         (use-package agda2-mode
           :ensure nil
           :commands agda2-mode
           :mode (("\\.agda\\'" . agda2-mode)
                  ("\\.lagda.md\\'" . agda2-mode)))
         #+end_src
         ** ELisp
         #+begin_src emacs-lisp
         #+end_src
         ** OCaml
         #+begin_src emacs-lisp
         (use-package tuareg
             :straight t)

         (use-package merlin
             :straight t
             :after tuareg)

         #+end_src
         ** Lean
         #+begin_src emacs-lisp
         (use-package lean4-mode
           :straight (lean4-mode
         	     :type git
         	     :host github
         	     :repo "leanprover/lean4-mode"
         	     :files ("*.el" "data"))
           ;; to defer loading the package until required
           :commands (lean4-mode))
         #+end_src
         ** Nix
         #+begin_src emacs-lisp
         (use-package nix-mode
            :straight t)

         (defun darwin-rebuild-switch () ())
         (defun nix-channel-update () ())
         (defun nix-collect-garbage-d () ())

         (global-set-key (kbd "C-x C-. C-n o") #'(lambda () (interactive) (find-file "~/.nixpkgs/darwin-configuration.nix")))
         (global-set-key (kbd "C-x C-. C-n r") #'darwin-rebuild-switch)
         (global-set-key (kbd "C-x C-. C-n u") #'nix-channel-update)
         (global-set-key (kbd "C-x C-. C-n d") #'nix-collect-garbage-d)
         #+end_src
         ** Javascript
         #+begin_src emacs-lisp
         (use-package js2-mode
             :straight t)
         #+end_src
         ** Python
         #+begin_src emacs-lisp
          ;; (use-package python-mode
          ;;  :straight t
          ;;  :defer t)
         #+end_src
         ** Swift
         #+begin_src emacs-lisp
         (use-package swift-mode
             :straight t)
         #+end_src
         * Data Serialization
         ** JSON
         #+begin_src emacs-lisp
         (use-package json-mode
           :straight t)
         #+end_src
         ** YAML
         #+begin_src emacs-lisp
         (use-package yaml-mode
            :straight t)
         #+end_src
         ** csv
         #+begin_src emacs-lisp
         (use-package csv-mode
           :straight t)
         #+end_src
* Password management
** pass
#+begin_src emacs-lisp
(use-package pass
  :straight t)
#+end_src
* Shell
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-. C-z r") #'(lambda () (interactive) (find-file "~/.zshrc")))
(global-set-key (kbd "C-x C-. C-z p") #'(lambda () (interactive) (find-file "~/.zprofile")))
(global-set-key (kbd "C-x C-. C-z e") #'(lambda () (interactive) (find-file "~/.zshenv")))
#+end_src
* Spelling and Thesaurus
** Jinx
#+begin_src emacs-lisp
(use-package jinx
  :straight t
  :bind
  (:map jinx-mode-map
    ("<C-m> C-n" . jinx-next)
    ("<C-m> C-p" . jinx-previous)))
#+end_src
** powerthesaurus
#+begin_src emacs-lisp
(use-package powerthesaurus
  :straight t
  :bind
  ("M-^" . powerthesaurus-lookup-dwim))
#+end_src
** define-word
#+begin_src emacs-lisp
(use-package define-word
  :straight t
  :bind
  ("M-#" . define-word-at-point))
#+end_src
* Markup languages
** Tex
*** cdlatex
#+begin_src emacs-lisp
(use-package cdlatex
    :straight t)
#+end_src
*** auctex
#+begin_src emacs-lisp
(use-package auctex
    :straight t
    :hook
    (LaTeX-mode . reftex-mode)
    (LaTeX-mode . cdlatex-mode)
    (LaTeX-mode . jinx-mode)
    (LaTeX-mode . (lambda () (display-line-numbers-mode 1)))
    :bind
    (:map LaTeX-mode-map
     ("<C-m> C-w" . avy-goto-subword-1)
     ("<C-m> C-," . avy-goto-subword-1)
     ("C-S-f" . subword-forward)
     ("C-S-b" . subword-backward)
     ("C-S-k" . subword-kill)
     ("C-S-t" . subword-transpose)
     ("C-<backspace>" . subword-backward-kill))
    :mode
    ("\\.tex\\'" . LaTeX-mode)
    ("\\.mng\\'" . LaTeX-mode)
    ("\\.lhs\\'" . LaTeX-mode))
#+end_src
** ott
#+begin_src emacs-lisp
(use-package ott-mode
    :ensure nil
    :load-path "~/.emacs.d/ott-mode")

(define-prefix-command 'ctl-c-map)

(setq ott-mode-map (make-sparse-keymap))

(define-keymap
   :name ott-mode-map
   :parent ctl-c-map)
#+end_src
** markdown-mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t)
#+end_src
** rst-mode
#+begin_src emacs-lisp
(setq rst-pdf-program "/Applications/Skim.app/Contents/MacOS/Skim")
#+end_src
* Messaging and Mail
** ement
#+begin_src emacs-lisp
(use-package ement
    :straight t
    :config
    (setq ement-auto-sync nil))
#+end_src
** telega
#+begin_src emacs-lisp
(use-package telega
    :config
    (setq telega-chat-bidi-display-reordering t
          telega-use-images t))
#+end_src
** notmuch
#+begin_src emacs-lisp
(setq user-full-name "Artin Ghasivand"
      user-mail-address "ghasivand.artin@gmail.com"
      message-send-mail-function 'smtpmail-send-it
      send-mail-function 'smtpmail-send-it
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-stream-type 'starttls
      smtpmail-smtp-service 587
      message-sendmail-envelope-from 'header
      message-kill-buffer-on-exit t)

(use-package notmuch
  :straight t)

(global-set-key (kbd "C-x M") 'compose-mail)
#+end_src
* RSS
** elfeed
#+begin_src emacs-lisp
(use-package elfeed
   :straight t)
#+end_src
* Profiling
#+begin_src emacs-lisp
(use-package esup
  :straight t)
#+end_src
* Fun!
#+begin_src emacs-lisp
(use-package speed-type
    :straight t
    :bind
    (:map speed-type-mode-map
     ("C-i" . speed-type--replay)))
#+end_src

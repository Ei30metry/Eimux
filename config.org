#+title: My Emacs config
#+AUTHOR: Artin Ghasivand

* GUI settings
#+begin_src emacs-lisp
   (setq scroll-conservatively 101)
   (if (display-graphic-p)
       (menu-bar-mode 1)
       (menu-bar-mode -1))

   (tool-bar-mode -1)
   (scroll-bar-mode -1)
   (pixel-scroll-precision-mode 1)
   (global-display-line-numbers-mode 1)
   (global-visual-line-mode 1)
   (setq display-line-numbers-type 'relative)
#+end_src

* Initial modes
#+begin_src emacs-lisp
(winner-mode 1)
#+end_src
* Disabling default buffers and backup files
#+begin_src emacs-lisp
(setq-default message-log-max t)

(add-hook 'minibuffer-exit-hook
      #'(lambda ()
         (let ((buffer "*Completions*"))
           (and (get-buffer buffer)
            (kill-buffer buffer)))))

(setq-default warning-minimum-level nil)
(setq make-backup-files nil)
(setq auto-save-default nil)
(setq auto-save-list-file-prefix nil)

;; TODO Fix this
(setq-default show-trailing-whitespace nil)
#+end_src
* UI
** Theme
#+begin_src emacs-lisp
   (use-package doom-themes
   :straight t
   :config
   ;; Global settings (defaults)
   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
         doom-themes-enable-italic t)
   (doom-themes-visual-bell-config)
   (doom-themes-org-config))

   (load-theme 'doom-sourcerer t)
#+end_src
** Font
#+begin_src emacs-lisp
(set-face-attribute 'default nil
                    :font "Andale Mono 14"
                    ;;:font "Jetbrains Mono 14"
                    :weight 'medium)

(set-face-attribute 'variable-pitch nil
                    ;;:font "Jetbrains Mono 14"
                    :font "Andale Mono 14"
                    :weight 'medium)

(set-face-attribute 'fixed-pitch nil
                    ;;:font "Jetbrains Mono 14"
                    :font "Andale Mono 14"
                    :weight 'medium)
;; needed for emacsclient
(add-to-list 'default-frame-alist '(font . "Andale Mono 14"))
#+end_src

** Icons
#+begin_src emacs-lisp
  (use-package all-the-icons
    :straight t
    :if (display-graphic-p))
#+end_src

** Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
  :straight t
  :init
  (setq dashboard-set-heading-icons nil
        dashboard-icon-type 'all-the-icons
        dashboard-set-file-icons t
        dashboard-banner-logo-title "It's good to have an end to journey toward; but it's the journey that matters in the end."
        dashboard-startup-banner "~/.emacs.d/images/lambda.png"
        dashboard-center-content t
        dashboard-items '((agenda . 15)))
  :config
  (dashboard-setup-startup-hook)
  (dashboard-modify-heading-icons '((recents . "file-text")
                                    (bookmarks . "book"))))

#+end_src
* OS packages
** osx-lib
#+begin_src emacs-lisp
(use-package osx-lib
  :straight t)
#+end_src
** osx-plist
#+begin_src emacs-lisp
(use-package osx-plist
  :straight t)
#+end_src
** Prevent Emacs from closing
#+begin_src emacs-lisp
(global-set-key (kbd "M-q") 'kill-emacs)
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src
* Keybidings
** Functions
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-o") #'(lambda () (interactive) (find-file "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-x C-r") #'(lambda () (interactive) (load-file "~/.emacs.d/init.el")))

  ;;;###autpoload
    (defun +company-has-completion-p ()
      "Return non-nil if a completion candidate exists at point."
      (when company-mode
        (unless company-candidates-length
          (company-manual-begin))
        (= company-candidates-length 1)))

    (defun kill-all-buffers (&optional buffer-list interactive)
      "Kill all buffers and closes their windows.

    If the prefix arg is passed, doesn't close windows and only kill buffers that
    belong to the current project."
      (interactive
       (list (if current-prefix-arg
                 (doom-project-buffer-list)
               (doom-buffer-list))
             t))
      (if (null buffer-list)
          (message "No buffers to kill")
        (save-some-buffers)
        (delete-other-windows)
        (when (memq (current-buffer) buffer-list)
          (switch-to-buffer (doom-fallback-buffer)))
        (mapc #'kill-buffer buffer-list)
        (doom--message-or-count
         interactive "Killed %d buffers"
         (- (length buffer-list)
            (length (cl-remove-if-not #'buffer-live-p buffer-list))))))

    ;;;###autoload
    (defun +company/toggle-auto-completion ()
      "Toggle as-you-type code completion."
      (interactive)
      (require 'company)
      (setq company-idle-delay (unless company-idle-delay 0.2))
      (message "Auto completion %s"
               (if company-idle-delay "enabled" "disabled")))


    ;;;###autoload
    (defun +company/complete ()
      "Bring up the completion popup. If only one result, complete it."
      (interactive)
      (require 'company)
      (when (ignore-errors
              (/= (point)
                  (cdr (bounds-of-thing-at-point 'symbol))))
        (save-excursion (insert " ")))
      (when (and (company-manual-begin)
                 (= company-candidates-length 1))
        (company-complete-common)))

    ;;;###autoload
    (defun +company/dabbrev ()
      "Invokes `company-dabbrev-code' in prog-mode buffers and `company-dabbrev'
    everywhere else."
      (interactive)
      (call-interactively
       (if (derived-mode-p 'prog-mode)
           #'company-dabbrev-code
         #'company-dabbrev)))
#+end_src
** macOS
#+begin_src emacs-lisp
(setq mac-option-key-is-meta nil 
      mac-command-key-is-meta t
      mac-command-modifier 'meta
      mac-option-modifier 'super)

#+end_src
* Org-mode
** Improving upon org-mode
*** Org-mode
#+begin_src emacs-lisp
  (use-package org
    :straight t
    :init
    (setq org-directory "~/Journal")
    (unless (file-exists-p org-directory)
      (mkdir org-directory t))
    :config
    (setq org-startup-indented t)
    (setq org-log-into-drawer t)
    (setq org-treat-insert-todo-heading-as-state-change t)
    (setq org-return-follows-link t)
    (setq org-src-tab-acts-natively nil)
    (setq org-agenda-files '("~/Agenda/todo.org" "~/Agenda/habits.org"))
    (add-hook 'org-mode-hook 'smartparens-mode)
    (add-hook 'org-agenda-mode-hook
          #'(lambda ()
            (visual-line-mode -1)
            (toggle-truncate-lines 1)
            (display-line-numbers-mode 0))))
    ;; (add-hook 'org-mode-hook
    ;;       (lambda ()
    ;;         (rainbow-delimiters-mode -1)))
#+end_src
*** Org-Capture
#+begin_src emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/Agenda/todo.org" "Inbox")
         "* TODO %?\n  %i\n")))
#+end_src
*** Org-contrib
#+begin_src emacs-lisp
(use-package org-contrib
  :straight t
  :defer t
  :after org
  :config
  (require 'ox-extra)
  (ox-extras-activate '(latex-header-blocks ignore-headlines)))
#+end_src
*** Org-bullets
#+begin_src emacs-lisp
(use-package org-bullets
   :straight t
   :after org)

(add-hook 'org-mode-hook #'(lambda () (org-bullets-mode 1)))
#+end_src
*** Org-tempo
#+begin_src emacs-lisp
(with-eval-after-load 'org
(require 'org-tempo)
(setq org-structure-template-alist
      '(("el" . "src emacs-lisp")
        ("py" . "src python")
        ("sq" . "src sql")
        ("hs" . "src haskell")
        ("rs" . "src rust")
        ("c" . "src c"))))
#+end_src
*** TOC-org
#+begin_src emacs-lisp
(use-package toc-org
  :straight t
  :after org
  :config
  (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src
** Productivity
*** Org-super-agenda
#+begin_src emacs-lisp
  ;; (use-package org-super-agenda
  ;;    :straight t
  ;;    :after org
  ;;    :defer t)
#+end_src
*** Books
#+begin_src emacs-lisp
(use-package org-books
  :straight t
  :after org
  :defer t
  :config
  (setq org-books-file "~/Agenda/books.org"))
#+end_src
*** Deft
#+begin_src emacs-lisp
(use-package deft
    :straight t
    :config
    (setq deft-directory "~/Journal"
          deft-extensions '("md" "org" "txt")
          deft-recursive t))

(setq deft-directory "~/Journal"
      deft-extensions '("md" "org" "txt")
      deft-recursive t)
#+end_src
*** Org-journal
#+begin_src emacs-lisp
(use-package org-journal
    :straight t
    :after org)

(setq org-journal-date-prefix "#+TITLE: "
      org-journal-dir "~/Journal"
      org-journal-time-prefix "* "
      org-journal-date-format "%a, %Y-%m-%d"
      org-journal-file-format "%Y-%m-%d.org")



(setq org-directory "~/Journal")

#+end_src
*** Org-roam
#+begin_src emacs-lisp

#+end_src

(setq org-roam-directory "~/Research")
*** helm-bibtex
#+begin_src emacs-lisp
  ;; (use-package helm-bibtex
  ;;   :ensure t)
#+end_src
*** Org-ql
#+begin_src emacs-lisp
  ;; (use-package org-ql
  ;;   :ensure t)
  ;; (add-to-list 'load-path "~/.config/haskmacs/org-ql")
  ;; (add-to-list 'load-path "~/.config/haskmacs/peg")
  ;; (require 'org-ql)
#+end_src
* Which key
#+begin_src emacs-lisp
(use-package which-key
  :straight t
  :config
  (setq which-key-allow-imprecise-window-fit t)
  :init
  (which-key-mode))

(setq which-key-idle-delay 0.2)
#+end_src
* Media
** emms
#+begin_src emacs-lisp
(use-package emms :straight t :defer t)
#+end_src
** empv
#+begin_src emacs-lisp
  (use-package empv :straight t :defer nil)

  ;; These functions
  ;; One just logs to the file with the same name at (Note Dir)
  ;; One that stops the music and asks for the description and then logs the timestamp with the issue
  ;; It should also have this variables:
  ;; (podcast-dir)
  ;; (default-description)
  (setq episodes-audio-directory "/Users/artin/Podcast/Haskell Interlude/Episodes/"
        episodes-notes-directory "/Users/artin/Podcast/Haskell Interlude/Notes/"
        default-description "Volume drop")

  ;; (message episodes-notes-directory)

  ;; TODO Check to see if the file exists, if it doesn't, create it first
  ;; TODO Write a range, instead of an absolute timestamp like 52:00 -- 52:01 : Blah
  ;; NOTE Remmber to re-read the buffer in the end

  (defun timestamp-to-MM-SS (timestamp)
     "Convert seconds to MM:SS format"
     (let* ((seconds (% timestamp 60))
            (minutes (/ (- timestamp seconds) 60))
            (prettify-time (lambda (x) (if (< x 10) (concat "0" (number-to-string x)) (number-to-string x))))
            (seconds-pretty (funcall prettify-time seconds))
            (minutes-pretty (funcall prettify-time minutes)))
      (concat minutes-pretty ":" seconds-pretty)))

  (defun write-timerange (file &optional description)
      "Write the timestamp of the currently playing episode to its note file"
      (interactive)
      (let* ((timestamp (empv--send-command-sync (list 'get_property 'time-pos)))
            (timestamp-range (concat (timestamp-to-MM-SS (- (truncate timestamp) 1))
                                     " -- "
                                     (timestamp-to-MM-SS (+ (truncate timestamp) 1)))))
          (if description
                 (write-region (concat timestamp-range " : " description "\n") nil file 'append)
                 (write-region (concat timestamp-range " : " default-description "\n") nil file 'append)
                 (revert-buffer-quick file)))) ;; TODO This is a hack, fix this


  (defun write-to-episode-note-file ()
     (interactive)
     (let ((current-episode (empv--send-command-sync (list 'get_property 'filename/no-ext))))
     (write-timerange--with
            (expand-file-name (concat current-episode ".txt") episodes-notes-directory))))
#+end_src
* Document
** nov
#+begin_src emacs-lisp
(use-package nov
   :straight t
   :defer t
   :hook
   (nov-mode . (lambda () (display-line-numbers-mode -1))))

(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+end_src
** PDF tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :straight t
  :defer t
  :config
  (add-hook 'pdf-view-mode-hook #'(lambda () (display-line-numbers-mode -1)))
  (pdf-tools-install))
#+end_src
* Tools
** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :straight t
  :config
  :init
  (setq persp-suppress-no-prefix-key-warning t)
  (persp-mode))
#+end_src
** Rainbow delimiters
#+begin_src emacs-lisp
;; (add-to-list 'load-path "~/.config/haskmacs/rainbow-delimiters")
;; (require 'rainbow-delimiters)
;; (use-package rainbow-delimiters
;;   :ensure t)
;; (add-hook 'lisp-mode #'rainbow-delimiters-mode)
#+end_src
** magit
#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :defer t
    :commands magit-status)
#+end_src
** eglot
#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)
  (use-package eglot
    :straight t
    :defer t
    :commands eglot
    :config
    (setq-default eglot-workspace-configuration
          '((haskell (plugin (stan (globalOn . :json-false)))))))
#+end_src
** eglot-booster
#+begin_src emacs-lisp
(use-package eglot-booster
  :straight (eglot-booster
	     :type git
	     :host github
	     :repo "jdtsmith/eglot-booster"
	     :files ("*.el"))
  :after eglot
  :config (eglot-booster-mode-mode))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :straight t
  :init
  (smartparens-global-mode))
#+end_src
** hl-todo
#+begin_src emacs-lisp
(use-package hl-todo
  :straight t
  :init
  (hl-todo-mode))
#+end_src
** Vertico
#+begin_src emacs-lisp
(use-package vertico
  :straight t
  :bind (:map vertico-map
            ("C-n" . vertico-next)
            ("C-p" . vertico-previous))
  :custom
  (vertico-cycle t)
  :init
  (vertico-mode))
#+end_src
** Savehist
#+begin_src emacs-lisp
(use-package savehist
  :straight t
  :init
  (savehist-mode))
#+end_src
** Company
#+begin_src emacs-lisp

(use-package company
  :straight t
  :config
  (setq company-idle-delay 0.20)
  (setq company-minimum-prefix-length 2)
  (setq company-show-number t))

(add-hook 'after-init-hook 'global-company-mode)

#+end_src
** Company-Box
#+begin_src emacs-lisp
(use-package company-box
  :straight t
  :after company-mode)
#+end_src
** Orderless
#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Terminal
*** term
#+begin_src emacs-lisp
(add-hook 'term-mode-hook #'(lambda () (display-line-numbers-mode -1)))
(setq explicit-shell-file-name "zsh")
#+end_src
*** vterm
#+begin_src emacs-lisp
(use-package vterm
  :straight t
  :defer t
  :config
  (add-hook 'vterm-mode-hook #'(lambda () (display-line-numbers-mode -1))))
#+end_src

*** eshell
#+begin_src emacs-lisp
  ;; (use-package eshell
  ;;   :straight t
  ;;   (add-hook 'eshell-mode-hook #'(lambda () (display-line-numbers-mode -1))))
  (add-hook 'eshell-mode-hook #'(lambda () (display-line-numbers-mode -1)))
#+end_src

** Projectile
#+begin_src emacs-lisp
(use-package projectile
  :straight t
  :config
  (setq projectile-enable-caching t
        projectile-auto-update-cache t
        projectile-discover-projects-in-directory "~/Programming/projects/")
  :init
  (projectile-mode 1))
#+end_src
** Xref
#+begin_src emacs-lisp
(use-package xref
  :straight t)
#+end_src
** Tab management
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default default-tab-width 4)
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src

** Imenu
#+begin_src emacs-lisp
(use-package imenu
  :straight t)
#+end_src
** Swiper
#+begin_src emacs-lisp
(use-package swiper
  :straight t
  :bind
  ("M-s s" . swiper))
#+end_src
** Consult
#+begin_src emacs-lisp
(use-package consult
   :straight t
   :bind
   ("M-g i" . consult-imenu))
#+end_src
*** Consult-eglot
#+begin_src emacs-lisp
(use-package consult-eglot
  :straight t
  :after eglot)
#+end_src
** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :init
  (marginalia-mode))
#+end_src
* Programming Languages
** Haskell
*** Haskell-mode
#+begin_src emacs-lisp
  (use-package haskell-mode
    :straight t
    :config
    (setq haskell-font-lock-symbols t)
    (setq haskell-stylish-on-save nil)
    (setq haskell-process-log nil)
    :hook
    (haskell-mode . interactive-haskell-mode)
    (haskell-mode . haskell-auto-insert-module-template)
    (haskell-mode . haskell-decl-scan-mode)
    (haskell-mode . turn-on-haskell-indentation))
#+end_src

** Agda
#+begin_src elisp
;; Get the directory containing agda2-mode.el using agda-mode locate
(setq agda-mode-directory
      (file-name-directory (substring (shell-command-to-string "agda-mode locate") 0 -1)))

;; Add the directory containing agda2-mode.el to load-path
(add-to-list 'load-path agda-mode-directory)

;; Use-package configuration for agda2-mode
(use-package agda2-mode
  :ensure nil
  :commands agda2-mode
  :mode (("\\.agda\\'" . agda2-mode)
         ("\\.lagda.md\\'" . agda2-mode)))
#+end_src
** OCaml
#+begin_src emacs-lisp
(use-package tuareg-mode
    :straight t
    :defer t)

(use-package merlin
    :straight t
    :after tuareg-mode)

#+end_src
** C
** Lean
#+begin_src emacs-lisp
(use-package lean4-mode
  :straight (lean4-mode
	     :type git
	     :host github
	     :repo "leanprover/lean4-mode"
	     :files ("*.el" "data"))
  ;; to defer loading the package until required
  :commands (lean4-mode))
#+end_src
** Nix
#+begin_src emacs-lisp
(use-package nix-mode
   :straight t
   :defer t)

#+end_src
** Javascript
#+begin_src emacs-lisp
(use-package js2-mode
    :straight t
    :defer t)
#+end_src
** Python
#+begin_src emacs-lisp
 ;; (use-package python-mode
 ;;  :straight t
 ;;  :defer t)
#+end_src
** Swift
#+begin_src emacs-lisp
(use-package swift-mode
    :straight t
    :defer t)
#+end_src

* Data Serialization
** JSON
#+begin_src emacs-lisp
(use-package json-mode
  :straight t
  :defer t)
#+end_src
** YAML
#+begin_src emacs-lisp
(use-package yaml-mode
  :straight t)
#+end_src
** CSV
#+begin_src emacs-lisp
(use-package csv-mode
  :straight t)
#+end_src

* Markup languages
** Latex mode
#+begin_src emacs-lisp
(use-package tex-mode
  :straight t)
#+end_src
** Ott
#+begin_src emacs-lisp
(use-package ott-mode
    :ensure nil
    :load-path "~/.emacs.d/ott-mode")
#+end_src
** Markdown mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t)
#+end_src

* Messaging and mail
** Ement
#+begin_src emacs-lisp
(use-package ement
    :straight t
    :defer t)
#+end_src
** Telega
#+begin_src emacs-lisp
  (use-package telega
      :straight t
      :defer t
      :config
      (setq telega-chat-bidi-display-reordering t)
      (setq telega-server-libs-prefix "/usr/local")
      :hook
      (telega-chat-mode . (lambda () (display-line-numbers-mode -1)))
      (telega-root-mode . (lambda () (display-line-numbers-mode -1))))

  ;; (defun get-tdlib-path ()
  ;;   (replace-regexp-in-string "\n$" "" (shell-command-to-string "nix-store -q --outputs $(nix-instantiate '<nixpkgs>' -A tdlib)")))

#+end_src
** mu4e
#+begin_src emacs-lisp
  ;; (use-package mu4e
  ;; :straight t)
#+end_src
* Profiling
#+begin_src emacs-lisp
(use-package esup
  :straight t)
#+end_src
